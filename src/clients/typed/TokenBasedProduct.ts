/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from '@algorandfoundation/algokit-utils/types/algorand-client'
import { ABIReturn, AppReturn, SendAppTransactionResult } from '@algorandfoundation/algokit-utils/types/app'
import { Arc56Contract, getArc56ReturnValue, getABIStructFromABITuple } from '@algorandfoundation/algokit-utils/types/app-arc56'
import {
  AppClient as _AppClient,
  AppClientMethodCallParams,
  AppClientParams,
  AppClientBareCallParams,
  CallOnComplete,
  AppClientCompilationParams,
  ResolveAppClientByCreatorAndName,
  ResolveAppClientByNetwork,
  CloneAppClientParams,
} from '@algorandfoundation/algokit-utils/types/app-client'
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory'
import { TransactionComposer, AppCallMethodCall, AppMethodCallTransactionArgument, SimulateOptions, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer'
import { SendParams, SendSingleTransactionResult, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction'
import { Address, encodeAddress, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk'
import SimulateResponse = modelsv2.SimulateResponse

export const APP_SPEC: Arc56Contract = {"arcs":[],"name":"TokenBasedProduct","structs":{"Discount":[{"name":"discountType","type":"uint64"},{"name":"discountValue","type":"uint64"},{"name":"expiresAt","type":"uint64"},{"name":"createdAt","type":"uint64"},{"name":"totalClaims","type":"uint64"}],"Subscription":[{"name":"subscriptionId","type":"uint64"},{"name":"productType","type":"uint64"},{"name":"createdAt","type":"uint64"},{"name":"expiresAt","type":"uint64"},{"name":"duration","type":"uint64"}]},"methods":[{"name":"create","desc":"Creates a new instance of the subscription service with the provided parameters.","args":[{"name":"product_name","type":"string","desc":"The title of the product offering subscription."},{"name":"subscription_name","type":"string","desc":"The title of product's subscription, for ex Plus, Pro, etc."},{"name":"manager","type":"address","desc":"The address of the manager of the subscription service."},{"name":"price","type":"uint64","desc":"The price of the subscription service."},{"name":"max_subscribers","type":"uint64","desc":"The maximum number of subscriptions to be sold."},{"name":"coin_id","type":"uint64","desc":"The ASA ID of the subscription service."},{"name":"oracle_id","type":"uint64","desc":"The ID of the Subtopia Price Oracle contract."},{"name":"unit_name","type":"string"},{"name":"image_url","type":"string"},{"name":"duration","type":"uint64","desc":"The duration of the subscription service."}],"returns":{"type":"void"},"events":[],"actions":{"create":["NoOp"],"call":[]}},{"name":"delete","desc":"Deletes the subscription service. Can only be called by the manager account\nwhen there are no active subscriptions or the lifecycle state is not active.","args":[],"returns":{"type":"void"},"events":[],"actions":{"create":[],"call":["DeleteApplication"]}},{"name":"get_version","args":[],"returns":{"type":"string"},"events":[],"readonly":true,"actions":{"create":[],"call":["NoOp"]}},{"name":"get_discount","desc":"Returns the discount if exists.","args":[],"returns":{"type":"(uint64,uint64,uint64,uint64,uint64)","desc":"An expression that returns the discount.","struct":"Discount"},"events":[],"readonly":true,"actions":{"create":[],"call":["NoOp"]}},{"name":"get_subscription","desc":"Retrieves the subscription details of a given subscriber.","args":[{"name":"subscriber","type":"address","desc":"The subscriber address."}],"returns":{"type":"(uint64,uint64,uint64,uint64,uint64)","desc":"An expression that retrieves the subscription details.","struct":"Subscription"},"events":[],"readonly":true,"actions":{"create":[],"call":["NoOp"]}},{"name":"update_oracle_id","desc":"Updates the ORACLE (Subtopia Price Oracle) application ID.\nArs: new_oracle (abi.Application): The new ORACLE application ID.","args":[{"name":"new_oracle","type":"application"}],"returns":{"type":"void"},"events":[],"actions":{"create":[],"call":["NoOp"]}},{"name":"update_manager","desc":"Updates the manager account of the subscription service.","args":[{"name":"new_manager_account","type":"address","desc":"The new manager account address."}],"returns":{"type":"void"},"events":[],"actions":{"create":[],"call":["NoOp"]}},{"name":"update_price","desc":"Updates the price of the subscription service.","args":[{"name":"new_price","type":"uint64"}],"returns":{"type":"void"},"events":[],"actions":{"create":[],"call":["NoOp"]}},{"name":"update_lifecycle","desc":"Set product lifecycle state (ENABLED/DISABLED). Only callable by the manager.","args":[{"name":"lifecycle_state","type":"uint64"}],"returns":{"type":"void"},"events":[],"actions":{"create":[],"call":["NoOp"]}},{"name":"is_discount_expired","desc":"Checks if the discount for the specified duration is expired.","args":[],"returns":{"type":"uint64","desc":"An expression that checks if the discount is expired."},"events":[],"readonly":true,"actions":{"create":[],"call":["NoOp"]}},{"name":"create_discount","desc":"Creates a new discount for the subscription service.","args":[{"name":"discount_type","type":"uint64","desc":"The type of discount (percentage or amount)."},{"name":"discount_value","type":"uint64","desc":"The discount value in micro ALGOs."},{"name":"expires_in","type":"uint64","desc":"The number of seconds to append to creation date"},{"name":"fee_txn","type":"pay","desc":"The transaction fee."}],"returns":{"type":"void"},"events":[],"actions":{"create":[],"call":["NoOp"]}},{"name":"delete_discount","desc":"Deletes a discount for the subscription service.","args":[],"returns":{"type":"void"},"events":[],"actions":{"create":[],"call":["NoOp"]}},{"name":"compute_price","desc":"Computes the price of the subscription for the given duration.","args":[{"name":"with_discount","type":"bool","desc":"Whether to apply a discount or not."}],"returns":{"type":"uint64","desc":"An expression that computes the price of the subscription."},"events":[],"actions":{"create":[],"call":["NoOp"]}},{"name":"create_subscription","desc":"Subscribes a user to the subscription service and creates a new\nsubscription.","args":[{"name":"subscriber","type":"address","desc":"The subscriber's address."},{"name":"creator_locker","type":"application","desc":"The locker of creator"},{"name":"oracle_id","type":"application","desc":"The oracle app used."},{"name":"fee_txn","type":"pay","desc":"The transaction fee paid to the app."},{"name":"platform_fee_txn","type":"pay","desc":"The platform fee paid."},{"name":"pay_txn","type":"txn","desc":"The payment transaction to fund the subscription."}],"returns":{"type":"uint64","desc":"An expression that subscribes the user and creates a new subscription."},"events":[],"actions":{"create":[],"call":["NoOp"]}},{"name":"is_subscriber","desc":"Checks if a given address is a subscriber of the subscription service.","args":[{"name":"subscriber","type":"address","desc":"The subscriber address."}],"returns":{"type":"uint64","desc":"An expression that checks if the address is a subscriber."},"events":[],"actions":{"create":[],"call":["NoOp"]}},{"name":"claim_subscription","desc":"Allows a subscriber to claim their subscription.","args":[{"name":"subscription","type":"asset","desc":"The subscription asset."}],"returns":{"type":"void"},"events":[],"actions":{"create":[],"call":["NoOp"]}},{"name":"transfer_subscription","desc":"Transfers a subscription from the sender's address to a new address.","args":[{"name":"new_subscriber","type":"address","desc":"The new address to transfer the subscription to."},{"name":"subscription","type":"asset","desc":"The subscription asset."}],"returns":{"type":"void"},"events":[],"actions":{"create":[],"call":["NoOp"]}},{"name":"delete_subscription","desc":"Unsubscribes a user from the subscription service and deletes the\nsubscription.","args":[{"name":"subscription","type":"asset","desc":"The subscription ASA ID."}],"returns":{"type":"uint64","desc":"An expression that unsubscribes the user and deletes the subscription."},"events":[],"actions":{"create":[],"call":["NoOp"]}}],"state":{"schema":{"global":{"ints":9,"bytes":7},"local":{"ints":0,"bytes":0}},"keys":{"global":{"coin_id":{"key":"Z3NfNw==","keyType":"AVMString","valueType":"AVMUint64","desc":"ASA ID of the subscription, default is ALGO"},"created_at":{"key":"Z3NfMTA=","keyType":"AVMString","valueType":"AVMUint64","desc":"Timestamp of the subscription service creation"},"duration":{"key":"Z3NfMTQ=","keyType":"AVMString","valueType":"AVMUint64","desc":"Duration of the subscription in seconds"},"extra_slot_1":{"key":"Z3NfMTU=","keyType":"AVMString","valueType":"AVMBytes","desc":"Reserved extra slot"},"extra_slot_2":{"key":"Z3NfMTY=","keyType":"AVMString","valueType":"AVMBytes","desc":"Reserved extra slot"},"image_url":{"key":"Z3NfMTM=","keyType":"AVMString","valueType":"AVMBytes","desc":"Image URL of the subscription NFT"},"lifecycle":{"key":"Z3NfOQ==","keyType":"AVMString","valueType":"AVMUint64","desc":"Lifecycle state of the subscription service"},"manager":{"key":"Z3NfMw==","keyType":"AVMString","valueType":"AVMBytes","desc":"Address of the manager of the subscription"},"max_subscribers":{"key":"Z3NfNg==","keyType":"AVMString","valueType":"AVMUint64","desc":"Max subscriptions to be sold"},"oracle_id":{"key":"Z3NfMTE=","keyType":"AVMString","valueType":"AVMUint64","desc":"ID of Subtopia Admin Oracle contract"},"price":{"key":"Z3NfNA==","keyType":"AVMString","valueType":"AVMUint64","desc":"Price of the subscription"},"product_name":{"key":"Z3NfMQ==","keyType":"AVMString","valueType":"AVMBytes","desc":"Name of the product providing subscription"},"product_type":{"key":"Z3NfOA==","keyType":"AVMString","valueType":"AVMUint64","desc":"Type of the subscription"},"subscription_name":{"key":"Z3NfMg==","keyType":"AVMString","valueType":"AVMBytes","desc":"Name of the service providing subscription"},"total_subscribers":{"key":"Z3NfNQ==","keyType":"AVMString","valueType":"AVMUint64","desc":"Total subscriptions sold"},"unit_name":{"key":"Z3NfMTI=","keyType":"AVMString","valueType":"AVMBytes","desc":"Unit name of the subscription NFT"}},"local":{},"box":{}},"maps":{"global":{},"local":{},"box":{}}},"source":{"approval":"I3ByYWdtYSB2ZXJzaW9uIDEwCmludGNibG9jayAwIDEgNCA2IDEwMDAwMCAxMDAwMCAyMTcwMCAzMTMwMApieXRlY2Jsb2NrIDB4IDB4NjI1ZjY0IDB4Njc3MzVmMzMgMHg2NzczNWYzNSAweDE1MWY3Yzc1IDB4Njc3MzVmMzEzMSAweDY3NzM1ZjM0IDB4Njc3MzVmMzkgMHg2NzczNWYzMTM0IDB4Njc3MzVmMzYgMHg2NzczNWYzMTMyIDB4Njc3MzVmMzEzMyAweDY3NzM1ZjM4IDB4Njc3MzVmMzcgMHg2NzczNWYzMTMwIDB4Njc3MzVmMzEgMHg2NDY1NjY2MTc1NmM3NCAweDY3NzM1ZjMyIDB4NmQ2MTZlNjE2NzY1NzIKdHhuIE51bUFwcEFyZ3MKaW50Y18wIC8vIDAKPT0KYm56IG1haW5fbDM4CnR4bmEgQXBwbGljYXRpb25BcmdzIDAKcHVzaGJ5dGVzIDB4OGUyM2RkYjUgLy8gImNyZWF0ZShzdHJpbmcsc3RyaW5nLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHN0cmluZyxzdHJpbmcsdWludDY0KXZvaWQiCj09CmJueiBtYWluX2wzNwp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweDI0Mzc4ZDNjIC8vICJkZWxldGUoKXZvaWQiCj09CmJueiBtYWluX2wzNgp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweDJmYmE1YTFiIC8vICJnZXRfdmVyc2lvbigpc3RyaW5nIgo9PQpibnogbWFpbl9sMzUKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHgwNjIxZGUxZiAvLyAiZ2V0X2Rpc2NvdW50KCkodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkiCj09CmJueiBtYWluX2wzNAp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweGMxNjg2ZmVkIC8vICJnZXRfc3Vic2NyaXB0aW9uKGFkZHJlc3MpKHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpIgo9PQpibnogbWFpbl9sMzMKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHhjNzljM2EwOCAvLyAidXBkYXRlX29yYWNsZV9pZChhcHBsaWNhdGlvbil2b2lkIgo9PQpibnogbWFpbl9sMzIKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHhjODZmZGIwMSAvLyAidXBkYXRlX21hbmFnZXIoYWRkcmVzcyl2b2lkIgo9PQpibnogbWFpbl9sMzEKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHhhNTc4MTgxOCAvLyAidXBkYXRlX3ByaWNlKHVpbnQ2NCl2b2lkIgo9PQpibnogbWFpbl9sMzAKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHg3YjFmOTY0ZCAvLyAidXBkYXRlX2xpZmVjeWNsZSh1aW50NjQpdm9pZCIKPT0KYm56IG1haW5fbDI5CnR4bmEgQXBwbGljYXRpb25BcmdzIDAKcHVzaGJ5dGVzIDB4YjdjZDc4MjkgLy8gImlzX2Rpc2NvdW50X2V4cGlyZWQoKXVpbnQ2NCIKPT0KYm56IG1haW5fbDI4CnR4bmEgQXBwbGljYXRpb25BcmdzIDAKcHVzaGJ5dGVzIDB4ZGMzZDRkMzMgLy8gImNyZWF0ZV9kaXNjb3VudCh1aW50NjQsdWludDY0LHVpbnQ2NCxwYXkpdm9pZCIKPT0KYm56IG1haW5fbDI3CnR4bmEgQXBwbGljYXRpb25BcmdzIDAKcHVzaGJ5dGVzIDB4MjAyOTMzYzIgLy8gImRlbGV0ZV9kaXNjb3VudCgpdm9pZCIKPT0KYm56IG1haW5fbDI2CnR4bmEgQXBwbGljYXRpb25BcmdzIDAKcHVzaGJ5dGVzIDB4YjRhMGQxMTUgLy8gImNvbXB1dGVfcHJpY2UoYm9vbCl1aW50NjQiCj09CmJueiBtYWluX2wyNQp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweGRkMDFkOTVhIC8vICJjcmVhdGVfc3Vic2NyaXB0aW9uKGFkZHJlc3MsYXBwbGljYXRpb24sYXBwbGljYXRpb24scGF5LHBheSx0eG4pdWludDY0Igo9PQpibnogbWFpbl9sMjQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHgxZWM1ZTk4YSAvLyAiaXNfc3Vic2NyaWJlcihhZGRyZXNzKXVpbnQ2NCIKPT0KYm56IG1haW5fbDIzCnR4bmEgQXBwbGljYXRpb25BcmdzIDAKcHVzaGJ5dGVzIDB4OThmNDMyYzAgLy8gImNsYWltX3N1YnNjcmlwdGlvbihhc3NldCl2b2lkIgo9PQpibnogbWFpbl9sMjIKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHgzYjM5NWE3NCAvLyAidHJhbnNmZXJfc3Vic2NyaXB0aW9uKGFkZHJlc3MsYXNzZXQpdm9pZCIKPT0KYm56IG1haW5fbDIxCnR4bmEgQXBwbGljYXRpb25BcmdzIDAKcHVzaGJ5dGVzIDB4NWIxYzA5MWQgLy8gImRlbGV0ZV9zdWJzY3JpcHRpb24oYXNzZXQpdWludDY0Igo9PQpibnogbWFpbl9sMjAKZXJyCm1haW5fbDIwOgp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydApjYWxsc3ViIGRlbGV0ZXN1YnNjcmlwdGlvbmNhc3Rlcl80OQppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sMjE6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CmNhbGxzdWIgdHJhbnNmZXJzdWJzY3JpcHRpb25jYXN0ZXJfNDgKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDIyOgp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydApjYWxsc3ViIGNsYWltc3Vic2NyaXB0aW9uY2FzdGVyXzQ3CmludGNfMSAvLyAxCnJldHVybgptYWluX2wyMzoKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQomJgphc3NlcnQKY2FsbHN1YiBpc3N1YnNjcmliZXJjYXN0ZXJfNDYKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDI0Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydApjYWxsc3ViIGNyZWF0ZXN1YnNjcmlwdGlvbmNhc3Rlcl80NQppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sMjU6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CmNhbGxzdWIgY29tcHV0ZXByaWNlY2FzdGVyXzQ0CmludGNfMSAvLyAxCnJldHVybgptYWluX2wyNjoKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQomJgphc3NlcnQKY2FsbHN1YiBkZWxldGVkaXNjb3VudGNhc3Rlcl80MwppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sMjc6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CmNhbGxzdWIgY3JlYXRlZGlzY291bnRjYXN0ZXJfNDIKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDI4Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydApjYWxsc3ViIGlzZGlzY291bnRleHBpcmVkY2FzdGVyXzQxCmludGNfMSAvLyAxCnJldHVybgptYWluX2wyOToKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQomJgphc3NlcnQKY2FsbHN1YiB1cGRhdGVsaWZlY3ljbGVjYXN0ZXJfNDAKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDMwOgp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydApjYWxsc3ViIHVwZGF0ZXByaWNlY2FzdGVyXzM5CmludGNfMSAvLyAxCnJldHVybgptYWluX2wzMToKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQomJgphc3NlcnQKY2FsbHN1YiB1cGRhdGVtYW5hZ2VyY2FzdGVyXzM4CmludGNfMSAvLyAxCnJldHVybgptYWluX2wzMjoKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQomJgphc3NlcnQKY2FsbHN1YiB1cGRhdGVvcmFjbGVpZGNhc3Rlcl8zNwppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sMzM6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CmNhbGxzdWIgZ2V0c3Vic2NyaXB0aW9uY2FzdGVyXzM2CmludGNfMSAvLyAxCnJldHVybgptYWluX2wzNDoKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQomJgphc3NlcnQKY2FsbHN1YiBnZXRkaXNjb3VudGNhc3Rlcl8zNQppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sMzU6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CmNhbGxzdWIgZ2V0dmVyc2lvbmNhc3Rlcl8zNAppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sMzY6CnR4biBPbkNvbXBsZXRpb24KcHVzaGludCA1IC8vIERlbGV0ZUFwcGxpY2F0aW9uCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydApjYWxsc3ViIGRlbGV0ZWNhc3Rlcl8zMwppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sMzc6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKPT0KJiYKYXNzZXJ0CmNhbGxzdWIgY3JlYXRlY2FzdGVyXzMyCmludGNfMSAvLyAxCnJldHVybgptYWluX2wzODoKdHhuIE9uQ29tcGxldGlvbgppbnRjXzEgLy8gT3B0SW4KPT0KYm56IG1haW5fbDQ0CnR4biBPbkNvbXBsZXRpb24KcHVzaGludCAyIC8vIENsb3NlT3V0Cj09CmJueiBtYWluX2w0Mwp0eG4gT25Db21wbGV0aW9uCmludGNfMiAvLyBVcGRhdGVBcHBsaWNhdGlvbgo9PQpibnogbWFpbl9sNDIKZXJyCm1haW5fbDQyOgp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQphc3NlcnQKY2FsbHN1YiB1cGRhdGVfMTIKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDQzOgp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQphc3NlcnQKY2FsbHN1YiBjbG9zZW91dF8xNAppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sNDQ6CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CmFzc2VydApjYWxsc3ViIG9wdGluXzEzCmludGNfMSAvLyAxCnJldHVybgoKLy8gaW50X3RvX2FzY2lpCmludHRvYXNjaWlfMDoKcHJvdG8gMSAxCnB1c2hieXRlcyAweDMwMzEzMjMzMzQzNTM2MzczODM5IC8vICIwMTIzNDU2Nzg5IgpmcmFtZV9kaWcgLTEKaW50Y18xIC8vIDEKZXh0cmFjdDMKcmV0c3ViCgovLyBpdG9hCml0b2FfMToKcHJvdG8gMSAxCmZyYW1lX2RpZyAtMQppbnRjXzAgLy8gMAo9PQpibnogaXRvYV8xX2w1CmZyYW1lX2RpZyAtMQpwdXNoaW50IDEwIC8vIDEwCi8KaW50Y18wIC8vIDAKPgpibnogaXRvYV8xX2w0CmJ5dGVjXzAgLy8gIiIKaXRvYV8xX2wzOgpmcmFtZV9kaWcgLTEKcHVzaGludCAxMCAvLyAxMAolCmNhbGxzdWIgaW50dG9hc2NpaV8wCmNvbmNhdApiIGl0b2FfMV9sNgppdG9hXzFfbDQ6CmZyYW1lX2RpZyAtMQpwdXNoaW50IDEwIC8vIDEwCi8KY2FsbHN1YiBpdG9hXzEKYiBpdG9hXzFfbDMKaXRvYV8xX2w1OgpwdXNoYnl0ZXMgMHgzMCAvLyAiMCIKaXRvYV8xX2w2OgpyZXRzdWIKCi8vIGlubmVyX3VzZF9pbl9taWNyb2FsZ28KaW5uZXJ1c2Rpbm1pY3JvYWxnb18yOgpwcm90byAyIDEKZnJhbWVfZGlnIC0yCnB1c2hieXRlcyAweDc1NzA2NDYxNzQ2NTY0NWY2MTc0IC8vICJ1cGRhdGVkX2F0IgphcHBfZ2xvYmFsX2dldF9leApzdG9yZSA1MgpzdG9yZSA1MQpmcmFtZV9kaWcgLTIKcHVzaGJ5dGVzIDB4NjQ2NTYzNjk2ZDYxNmM3MyAvLyAiZGVjaW1hbHMiCmFwcF9nbG9iYWxfZ2V0X2V4CnN0b3JlIDU0CnN0b3JlIDUzCmZyYW1lX2RpZyAtMgpwdXNoYnl0ZXMgMHg3MDcyNjk2MzY1IC8vICJwcmljZSIKYXBwX2dsb2JhbF9nZXRfZXgKc3RvcmUgNTYKc3RvcmUgNTUKbG9hZCA1MQpzdG9yZSA0NApsb2FkIDUzCnN0b3JlIDQ2CmxvYWQgNTUKc3RvcmUgNDcKZ2xvYmFsIExhdGVzdFRpbWVzdGFtcApsb2FkIDQ0Ci0KcHVzaGludCA4NjQwMCAvLyA4NjQwMAo+CmJueiBpbm5lcnVzZGlubWljcm9hbGdvXzJfbDMKaW5uZXJ1c2Rpbm1pY3JvYWxnb18yX2wxOgpmcmFtZV9kaWcgLTEKaW50YyA1IC8vIDEwMDAwCioKcHVzaGludCAxMCAvLyAxMApsb2FkIDQ2CmV4cAoqCmxvYWQgNDcKLwppbnRjIDUgLy8gMTAwMDAKLwppbnRjIDUgLy8gMTAwMDAKKgpzdG9yZSA1MApsb2FkIDUwCmludGMgNCAvLyAxMDAwMDAKPApieiBpbm5lcnVzZGlubWljcm9hbGdvXzJfbDQKaW50YyA0IC8vIDEwMDAwMApyZXRzdWIKaW5uZXJ1c2Rpbm1pY3JvYWxnb18yX2wzOgpwdXNoaW50IDIgLy8gMgpzdG9yZSA0NgpwdXNoaW50IDMwIC8vIDMwCnN0b3JlIDQ3CmIgaW5uZXJ1c2Rpbm1pY3JvYWxnb18yX2wxCmlubmVydXNkaW5taWNyb2FsZ29fMl9sNDoKbG9hZCA1MApyZXRzdWIKCi8vIGlubmVyX2NyZWF0ZV9hc3NldAppbm5lcmNyZWF0ZWFzc2V0XzM6CnByb3RvIDMgMQppdHhuX2JlZ2luCnB1c2hpbnQgMyAvLyBhY2ZnCml0eG5fZmllbGQgVHlwZUVudW0KaW50Y18xIC8vIDEKaXR4bl9maWVsZCBDb25maWdBc3NldFRvdGFsCmludGNfMCAvLyAwCml0eG5fZmllbGQgQ29uZmlnQXNzZXREZWNpbWFscwppbnRjXzEgLy8gMQppdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0RGVmYXVsdEZyb3plbgpmcmFtZV9kaWcgLTIKaXR4bl9maWVsZCBDb25maWdBc3NldFVuaXROYW1lCmZyYW1lX2RpZyAtMwppdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0TmFtZQpmcmFtZV9kaWcgLTEKaXR4bl9maWVsZCBDb25maWdBc3NldFVSTApnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwppdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0TWFuYWdlcgpnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwppdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0UmVzZXJ2ZQpnbG9iYWwgWmVyb0FkZHJlc3MKaXR4bl9maWVsZCBDb25maWdBc3NldEZyZWV6ZQpnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwppdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0Q2xhd2JhY2sKaW50Y18wIC8vIDAKaXR4bl9maWVsZCBGZWUKaXR4bl9zdWJtaXQKaXR4biBDcmVhdGVkQXNzZXRJRApyZXRzdWIKCi8vIGlubmVyX3RyYW5zZmVyX2Fzc2V0CmlubmVydHJhbnNmZXJhc3NldF80Ogpwcm90byAzIDAKaXR4bl9iZWdpbgppbnRjXzIgLy8gYXhmZXIKaXR4bl9maWVsZCBUeXBlRW51bQpmcmFtZV9kaWcgLTMKdHhuYXMgQXNzZXRzCml0eG5fZmllbGQgWGZlckFzc2V0CmludGNfMSAvLyAxCml0eG5fZmllbGQgQXNzZXRBbW91bnQKZnJhbWVfZGlnIC0yCml0eG5fZmllbGQgQXNzZXRTZW5kZXIKZnJhbWVfZGlnIC0xCml0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgppbnRjXzAgLy8gMAppdHhuX2ZpZWxkIEZlZQppdHhuX3N1Ym1pdApyZXRzdWIKCi8vIGlubmVyX2RlbGV0ZV9hc3NldAppbm5lcmRlbGV0ZWFzc2V0XzU6CnByb3RvIDEgMAppdHhuX2JlZ2luCnB1c2hpbnQgMyAvLyBhY2ZnCml0eG5fZmllbGQgVHlwZUVudW0KZnJhbWVfZGlnIC0xCnR4bmFzIEFzc2V0cwppdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0CmludGNfMCAvLyAwCml0eG5fZmllbGQgRmVlCml0eG5fc3VibWl0CnJldHN1YgoKLy8gaW5uZXJfZGVsZXRlX3N1YnNjcmlwdGlvbgppbm5lcmRlbGV0ZXN1YnNjcmlwdGlvbl82Ogpwcm90byAyIDAKZnJhbWVfZGlnIC0yCmZyYW1lX2RpZyAtMQp0eG5hcyBBc3NldHMKYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCnN0b3JlIDQ5CnN0b3JlIDQ4CmxvYWQgNDkKbG9hZCA0OAppbnRjXzAgLy8gMAo+CiYmCmJueiBpbm5lcmRlbGV0ZXN1YnNjcmlwdGlvbl82X2wzCmlubmVyZGVsZXRlc3Vic2NyaXB0aW9uXzZfbDE6CmZyYW1lX2RpZyAtMQpjYWxsc3ViIGlubmVyZGVsZXRlYXNzZXRfNQpieXRlY18zIC8vICJnc181IgphcHBfZ2xvYmFsX2dldAppbnRjXzAgLy8gMAohPQpieiBpbm5lcmRlbGV0ZXN1YnNjcmlwdGlvbl82X2w0CmJ5dGVjXzMgLy8gImdzXzUiCmJ5dGVjXzMgLy8gImdzXzUiCmFwcF9nbG9iYWxfZ2V0CmludGNfMSAvLyAxCi0KYXBwX2dsb2JhbF9wdXQKYiBpbm5lcmRlbGV0ZXN1YnNjcmlwdGlvbl82X2w0CmlubmVyZGVsZXRlc3Vic2NyaXB0aW9uXzZfbDM6CmZyYW1lX2RpZyAtMQpmcmFtZV9kaWcgLTIKZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKY2FsbHN1YiBpbm5lcnRyYW5zZmVyYXNzZXRfNApiIGlubmVyZGVsZXRlc3Vic2NyaXB0aW9uXzZfbDEKaW5uZXJkZWxldGVzdWJzY3JpcHRpb25fNl9sNDoKZnJhbWVfZGlnIC0yCmJveF9kZWwKcG9wCnJldHN1YgoKLy8gaW5uZXJfY29tcHV0ZV9leHBpcmF0aW9uCmlubmVyY29tcHV0ZWV4cGlyYXRpb25fNzoKcHJvdG8gMSAxCmZyYW1lX2RpZyAtMQppbnRjXzAgLy8gMAo9PQpibnogaW5uZXJjb21wdXRlZXhwaXJhdGlvbl83X2wyCmdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKZnJhbWVfZGlnIC0xCisKYiBpbm5lcmNvbXB1dGVleHBpcmF0aW9uXzdfbDMKaW5uZXJjb21wdXRlZXhwaXJhdGlvbl83X2wyOgppbnRjXzAgLy8gMAppbm5lcmNvbXB1dGVleHBpcmF0aW9uXzdfbDM6CnJldHN1YgoKLy8gaW5uZXJfaW5jcmVtZW50X2Rpc2NvdW50X3RvdGFsX2NsYWltc19jb3VudAppbm5lcmluY3JlbWVudGRpc2NvdW50dG90YWxjbGFpbXNjb3VudF84Ogpwcm90byAwIDAKYnl0ZWNfMCAvLyAiIgppbnRjXzAgLy8gMApkdXBuIDUKYnl0ZWNfMCAvLyAiIgppbnRjXzAgLy8gMApkdXAKYnl0ZWNfMCAvLyAiIgpkdXAKYnl0ZWNfMSAvLyAiYl9kIgpib3hfbGVuCnN0b3JlIDE3CnN0b3JlIDE2CmxvYWQgMTcKYnogaW5uZXJpbmNyZW1lbnRkaXNjb3VudHRvdGFsY2xhaW1zY291bnRfOF9sMgpieXRlY18xIC8vICJiX2QiCmJveF9nZXQKc3RvcmUgMTkKc3RvcmUgMTgKbG9hZCAxOQphc3NlcnQKbG9hZCAxOApmcmFtZV9idXJ5IDAKZnJhbWVfZGlnIDAKaW50Y18wIC8vIDAKZXh0cmFjdF91aW50NjQKZnJhbWVfYnVyeSAxCmlubmVyaW5jcmVtZW50ZGlzY291bnR0b3RhbGNsYWltc2NvdW50XzhfbDI6CmZyYW1lX2RpZyAwCnB1c2hpbnQgOCAvLyA4CmV4dHJhY3RfdWludDY0CmZyYW1lX2J1cnkgMgpmcmFtZV9kaWcgMApwdXNoaW50IDE2IC8vIDE2CmV4dHJhY3RfdWludDY0CmZyYW1lX2J1cnkgMwpmcmFtZV9kaWcgMApwdXNoaW50IDI0IC8vIDI0CmV4dHJhY3RfdWludDY0CmZyYW1lX2J1cnkgNApmcmFtZV9kaWcgMApwdXNoaW50IDMyIC8vIDMyCmV4dHJhY3RfdWludDY0CmZyYW1lX2J1cnkgNQpmcmFtZV9kaWcgNQppbnRjXzEgLy8gMQorCmZyYW1lX2J1cnkgNgpmcmFtZV9kaWcgMQppdG9iCmZyYW1lX2RpZyAyCml0b2IKY29uY2F0CmZyYW1lX2RpZyAzCml0b2IKY29uY2F0CmZyYW1lX2RpZyA0Cml0b2IKY29uY2F0CmZyYW1lX2RpZyA2Cml0b2IKY29uY2F0CmZyYW1lX2J1cnkgNwpieXRlY18xIC8vICJiX2QiCmJveF9kZWwKcG9wCmJ5dGVjXzEgLy8gImJfZCIKZnJhbWVfZGlnIDcKYm94X3B1dApyZXRzdWIKCi8vIGlubmVyX2NvbXB1dGVfZGlzY291bnRfcHJpY2UKaW5uZXJjb21wdXRlZGlzY291bnRwcmljZV85Ogpwcm90byAxIDEKYnl0ZWNfMCAvLyAiIgppbnRjXzAgLy8gMApkdXBuIDIKYnl0ZWNfMSAvLyAiYl9kIgpib3hfbGVuCnN0b3JlIDEzCnN0b3JlIDEyCmxvYWQgMTMKYm56IGlubmVyY29tcHV0ZWRpc2NvdW50cHJpY2VfOV9sMgpmcmFtZV9kaWcgLTEKYiBpbm5lcmNvbXB1dGVkaXNjb3VudHByaWNlXzlfbDkKaW5uZXJjb21wdXRlZGlzY291bnRwcmljZV85X2wyOgpieXRlY18xIC8vICJiX2QiCmJveF9nZXQKc3RvcmUgMTUKc3RvcmUgMTQKbG9hZCAxNQphc3NlcnQKbG9hZCAxNApmcmFtZV9idXJ5IDAKZnJhbWVfZGlnIDAKaW50Y18wIC8vIDAKZXh0cmFjdF91aW50NjQKZnJhbWVfYnVyeSAxCmZyYW1lX2RpZyAwCnB1c2hpbnQgOCAvLyA4CmV4dHJhY3RfdWludDY0CmZyYW1lX2J1cnkgMgpmcmFtZV9kaWcgMApwdXNoaW50IDE2IC8vIDE2CmV4dHJhY3RfdWludDY0CmZyYW1lX2J1cnkgMwpmcmFtZV9kaWcgMwpnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCjwKZnJhbWVfZGlnIDMKaW50Y18wIC8vIDAKPgomJgpibnogaW5uZXJjb21wdXRlZGlzY291bnRwcmljZV85X2w4CmZyYW1lX2RpZyAxCmludGNfMCAvLyAwCj09CmJueiBpbm5lcmNvbXB1dGVkaXNjb3VudHByaWNlXzlfbDcKZnJhbWVfZGlnIDEKaW50Y18xIC8vIDEKPT0KYm56IGlubmVyY29tcHV0ZWRpc2NvdW50cHJpY2VfOV9sNgpmcmFtZV9kaWcgLTEKYiBpbm5lcmNvbXB1dGVkaXNjb3VudHByaWNlXzlfbDkKaW5uZXJjb21wdXRlZGlzY291bnRwcmljZV85X2w2OgpjYWxsc3ViIGlubmVyaW5jcmVtZW50ZGlzY291bnR0b3RhbGNsYWltc2NvdW50XzgKZnJhbWVfZGlnIC0xCmZyYW1lX2RpZyAyCi0KYiBpbm5lcmNvbXB1dGVkaXNjb3VudHByaWNlXzlfbDkKaW5uZXJjb21wdXRlZGlzY291bnRwcmljZV85X2w3OgpjYWxsc3ViIGlubmVyaW5jcmVtZW50ZGlzY291bnR0b3RhbGNsYWltc2NvdW50XzgKZnJhbWVfZGlnIC0xCmZyYW1lX2RpZyAtMQpmcmFtZV9kaWcgMgoqCnB1c2hpbnQgMTAwIC8vIDEwMAovCi0KYiBpbm5lcmNvbXB1dGVkaXNjb3VudHByaWNlXzlfbDkKaW5uZXJjb21wdXRlZGlzY291bnRwcmljZV85X2w4OgpmcmFtZV9kaWcgLTEKaW5uZXJjb21wdXRlZGlzY291bnRwcmljZV85X2w5OgpmcmFtZV9idXJ5IDAKcmV0c3ViCgovLyBpbm5lcl9jb21wdXRlX3ByaWNlCmlubmVyY29tcHV0ZXByaWNlXzEwOgpwcm90byAxIDEKaW50Y18wIC8vIDAKYnl0ZWMgNiAvLyAiZ3NfNCIKYXBwX2dsb2JhbF9nZXQKZnJhbWVfYnVyeSAwCmZyYW1lX2RpZyAtMQppbnRjXzEgLy8gMQo9PQpibnogaW5uZXJjb21wdXRlcHJpY2VfMTBfbDIKZnJhbWVfZGlnIDAKYiBpbm5lcmNvbXB1dGVwcmljZV8xMF9sMwppbm5lcmNvbXB1dGVwcmljZV8xMF9sMjoKZnJhbWVfZGlnIDAKY2FsbHN1YiBpbm5lcmNvbXB1dGVkaXNjb3VudHByaWNlXzkKaW5uZXJjb21wdXRlcHJpY2VfMTBfbDM6CmZyYW1lX2J1cnkgMApyZXRzdWIKCi8vIGNyZWF0ZQpjcmVhdGVfMTE6CnByb3RvIDEwIDAKYnl0ZWMgMTMgLy8gImdzXzciCmludGNfMCAvLyAwCmFwcF9nbG9iYWxfcHV0CmJ5dGVjIDE0IC8vICJnc18xMCIKaW50Y18wIC8vIDAKYXBwX2dsb2JhbF9wdXQKYnl0ZWMgOCAvLyAiZ3NfMTQiCmludGNfMSAvLyAxCmFwcF9nbG9iYWxfcHV0CnB1c2hieXRlcyAweDY3NzM1ZjMxMzUgLy8gImdzXzE1IgpieXRlY18wIC8vICIiCmFwcF9nbG9iYWxfcHV0CnB1c2hieXRlcyAweDY3NzM1ZjMxMzYgLy8gImdzXzE2IgpieXRlY18wIC8vICIiCmFwcF9nbG9iYWxfcHV0CmJ5dGVjIDExIC8vICJnc18xMyIKcHVzaGJ5dGVzIDB4Njk3MDY2NzMzYTJmMmY2MjYxNjY3OTYyNjU2OTYzNjQ2NDdhMzc2YjYyNzU3ODYxNmE2YTM2NjI2ZjYyMzU2MjZhNzE3NDc3NjU3MTM2Nzc2MzY4NmI2NDZiNjk3MTM0NzY3NjY4Nzc3Mjc3NzI2ZTY1Mzc2OTdhMzQ2NjMyMzU3ODY5IC8vICJpcGZzOi8vYmFmeWJlaWNkZHo3a2J1eGFqajZib2I1YmpxdHdlcTZ3Y2hrZGtpcTR2dmh3cndybmU3aXo0ZjI1eGkiCmFwcF9nbG9iYWxfcHV0CmJ5dGVjIDcgLy8gImdzXzkiCmludGNfMCAvLyAwCmFwcF9nbG9iYWxfcHV0CmJ5dGVjXzIgLy8gImdzXzMiCmdsb2JhbCBDcmVhdG9yQWRkcmVzcwphcHBfZ2xvYmFsX3B1dApieXRlYyA5IC8vICJnc182IgppbnRjXzAgLy8gMAphcHBfZ2xvYmFsX3B1dApieXRlYyA1IC8vICJnc18xMSIKaW50Y18wIC8vIDAKYXBwX2dsb2JhbF9wdXQKYnl0ZWMgNiAvLyAiZ3NfNCIKaW50Y18wIC8vIDAKYXBwX2dsb2JhbF9wdXQKYnl0ZWMgMTUgLy8gImdzXzEiCmJ5dGVjIDE2IC8vICJkZWZhdWx0IgphcHBfZ2xvYmFsX3B1dApieXRlYyAxMiAvLyAiZ3NfOCIKcHVzaGludCAyIC8vIDIKYXBwX2dsb2JhbF9wdXQKYnl0ZWMgMTcgLy8gImdzXzIiCmJ5dGVjIDE2IC8vICJkZWZhdWx0IgphcHBfZ2xvYmFsX3B1dApieXRlY18zIC8vICJnc181IgppbnRjXzAgLy8gMAphcHBfZ2xvYmFsX3B1dApieXRlYyAxMCAvLyAiZ3NfMTIiCnB1c2hieXRlcyAweDUzNTQ1MCAvLyAiU1RQIgphcHBfZ2xvYmFsX3B1dApieXRlYyAxNSAvLyAiZ3NfMSIKZnJhbWVfZGlnIC0xMApleHRyYWN0IDIgMAphcHBfZ2xvYmFsX3B1dApieXRlYyAxNyAvLyAiZ3NfMiIKZnJhbWVfZGlnIC05CmV4dHJhY3QgMiAwCmFwcF9nbG9iYWxfcHV0CmJ5dGVjXzIgLy8gImdzXzMiCmZyYW1lX2RpZyAtOAphcHBfZ2xvYmFsX3B1dApieXRlYyAxMiAvLyAiZ3NfOCIKcHVzaGludCAyIC8vIDIKYXBwX2dsb2JhbF9wdXQKYnl0ZWMgNiAvLyAiZ3NfNCIKZnJhbWVfZGlnIC03CmFwcF9nbG9iYWxfcHV0CmJ5dGVjIDkgLy8gImdzXzYiCmZyYW1lX2RpZyAtNgphcHBfZ2xvYmFsX3B1dApieXRlYyAxMyAvLyAiZ3NfNyIKZnJhbWVfZGlnIC01CmFwcF9nbG9iYWxfcHV0CmJ5dGVjIDUgLy8gImdzXzExIgpmcmFtZV9kaWcgLTQKYXBwX2dsb2JhbF9wdXQKYnl0ZWMgMTAgLy8gImdzXzEyIgpmcmFtZV9kaWcgLTMKZXh0cmFjdCAyIDAKYXBwX2dsb2JhbF9wdXQKYnl0ZWMgMTEgLy8gImdzXzEzIgpmcmFtZV9kaWcgLTIKZXh0cmFjdCAyIDAKYXBwX2dsb2JhbF9wdXQKYnl0ZWMgOCAvLyAiZ3NfMTQiCmZyYW1lX2RpZyAtMQphcHBfZ2xvYmFsX3B1dApieXRlYyAxNCAvLyAiZ3NfMTAiCmdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKYXBwX2dsb2JhbF9wdXQKcmV0c3ViCgovLyB1cGRhdGUKdXBkYXRlXzEyOgpwcm90byAwIDAKdHhuIFR5cGVFbnVtCmludGNfMSAvLyBwYXkKPT0KdHhuIFR5cGVFbnVtCmludGNfMyAvLyBhcHBsCj09Cnx8CmJueiB1cGRhdGVfMTJfbDQKdHhuIFR5cGVFbnVtCmludGNfMiAvLyBheGZlcgo9PQpibnogdXBkYXRlXzEyX2wzCmVycgp1cGRhdGVfMTJfbDM6CnR4biBBc3NldENsb3NlVG8KZ2xvYmFsIFplcm9BZGRyZXNzCj09Ci8vIEFzc2V0VHJhbnNmZXJUcmFuc2FjdGlvbiBoYXMgaW5zZWN1cmUgZmllbGRzCmFzc2VydAp0eG4gUmVrZXlUbwpnbG9iYWwgWmVyb0FkZHJlc3MKPT0KLy8gQXNzZXRUcmFuc2ZlclRyYW5zYWN0aW9uIGhhcyBpbnNlY3VyZSBmaWVsZHMKYXNzZXJ0CmIgdXBkYXRlXzEyX2w1CnVwZGF0ZV8xMl9sNDoKdHhuIENsb3NlUmVtYWluZGVyVG8KZ2xvYmFsIFplcm9BZGRyZXNzCj09Ci8vIFBheW1lbnRUcmFuc2FjdGlvbiBoYXMgaW5zZWN1cmUgZmllbGRzCmFzc2VydAp0eG4gUmVrZXlUbwpnbG9iYWwgWmVyb0FkZHJlc3MKPT0KLy8gUGF5bWVudFRyYW5zYWN0aW9uIGhhcyBpbnNlY3VyZSBmaWVsZHMKYXNzZXJ0CnVwZGF0ZV8xMl9sNToKdHhuIFNlbmRlcgpnbG9iYWwgQ3JlYXRvckFkZHJlc3MKPT0KYXNzZXJ0CnJldHN1YgoKLy8gb3B0aW4Kb3B0aW5fMTM6CnByb3RvIDAgMAppbnRjXzAgLy8gMAp0eG4gVHlwZUVudW0KaW50Y18xIC8vIHBheQo9PQp0eG4gVHlwZUVudW0KaW50Y18zIC8vIGFwcGwKPT0KfHwKYm56IG9wdGluXzEzX2w0CnR4biBUeXBlRW51bQppbnRjXzIgLy8gYXhmZXIKPT0KYm56IG9wdGluXzEzX2wzCmVycgpvcHRpbl8xM19sMzoKdHhuIEFzc2V0Q2xvc2VUbwpnbG9iYWwgWmVyb0FkZHJlc3MKPT0KLy8gQXNzZXRUcmFuc2ZlclRyYW5zYWN0aW9uIGhhcyBpbnNlY3VyZSBmaWVsZHMKYXNzZXJ0CnR4biBSZWtleVRvCmdsb2JhbCBaZXJvQWRkcmVzcwo9PQovLyBBc3NldFRyYW5zZmVyVHJhbnNhY3Rpb24gaGFzIGluc2VjdXJlIGZpZWxkcwphc3NlcnQKYiBvcHRpbl8xM19sNQpvcHRpbl8xM19sNDoKdHhuIENsb3NlUmVtYWluZGVyVG8KZ2xvYmFsIFplcm9BZGRyZXNzCj09Ci8vIFBheW1lbnRUcmFuc2FjdGlvbiBoYXMgaW5zZWN1cmUgZmllbGRzCmFzc2VydAp0eG4gUmVrZXlUbwpnbG9iYWwgWmVyb0FkZHJlc3MKPT0KLy8gUGF5bWVudFRyYW5zYWN0aW9uIGhhcyBpbnNlY3VyZSBmaWVsZHMKYXNzZXJ0Cm9wdGluXzEzX2w1OgpnbG9iYWwgQ2FsbGVyQXBwbGljYXRpb25JRApmcmFtZV9idXJ5IDAKZnJhbWVfZGlnIDAKYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgpzdG9yZSAwCmdsb2JhbCBDcmVhdG9yQWRkcmVzcwo9PQovLyBPbmx5IGxvY2tlcnMgY3JlYXRlZCBieSBzYW1lIHJlZ2lzdHJ5IGNhbiBvcHQtaW4KYXNzZXJ0CnJldHN1YgoKLy8gY2xvc2VvdXQKY2xvc2VvdXRfMTQ6CnByb3RvIDAgMApnbG9iYWwgQ2FsbGVyQXBwbGljYXRpb25JRApieXRlYyAxOCAvLyAibWFuYWdlciIKYXBwX2dsb2JhbF9nZXRfZXgKc3RvcmUgMQpieXRlY18yIC8vICJnc18zIgphcHBfZ2xvYmFsX2dldAo9PQovLyBPbmx5IHNhbWUgbWFuYWdlciBjYW4gb3B0LW91dAphc3NlcnQKcmV0c3ViCgovLyBkZWxldGUKZGVsZXRlXzE1Ogpwcm90byAwIDAKdHhuIFNlbmRlcgpnbG9iYWwgQ3JlYXRvckFkZHJlc3MKPT0KLy8gdW5hdXRob3JpemVkCmFzc2VydApieXRlYyA3IC8vICJnc185IgphcHBfZ2xvYmFsX2dldAppbnRjXzEgLy8gMQo9PQovLyBBcHAgc3RpbGwgaGFzIGFjdGl2ZSBzdWJzY3JpYmVycyBvciBhY3RpdmUgbGlmZWN5Y2xlIHN0YXRlCmFzc2VydApieXRlY18zIC8vICJnc181IgphcHBfZ2xvYmFsX2dldAppbnRjXzAgLy8gMAo9PQovLyBBcHAgc3RpbGwgaGFzIGFjdGl2ZSBzdWJzY3JpYmVycyBvciBhY3RpdmUgbGlmZWN5Y2xlIHN0YXRlCmFzc2VydApyZXRzdWIKCi8vIGdldF92ZXJzaW9uCmdldHZlcnNpb25fMTY6CnByb3RvIDAgMQpieXRlY18wIC8vICIiCmR1cApwdXNoYnl0ZXMgMHgzMTJlMzAgLy8gIjEuMCIKZnJhbWVfYnVyeSAxCmZyYW1lX2RpZyAxCmxlbgppdG9iCmV4dHJhY3QgNiAwCmZyYW1lX2RpZyAxCmNvbmNhdApmcmFtZV9idXJ5IDEKZnJhbWVfZGlnIDEKZXh0cmFjdCAyIDAKZnJhbWVfYnVyeSAwCmZyYW1lX2RpZyAwCmxlbgppdG9iCmV4dHJhY3QgNiAwCmZyYW1lX2RpZyAwCmNvbmNhdApmcmFtZV9idXJ5IDAKcmV0c3ViCgovLyBnZXRfZGlzY291bnQKZ2V0ZGlzY291bnRfMTc6CnByb3RvIDAgMQpieXRlY18wIC8vICIiCmJ5dGVjXzEgLy8gImJfZCIKYm94X2dldApzdG9yZSAzCnN0b3JlIDIKbG9hZCAzCmFzc2VydApsb2FkIDIKZnJhbWVfYnVyeSAwCnJldHN1YgoKLy8gZ2V0X3N1YnNjcmlwdGlvbgpnZXRzdWJzY3JpcHRpb25fMTg6CnByb3RvIDEgMQpieXRlY18wIC8vICIiCmZyYW1lX2RpZyAtMQpib3hfZ2V0CnN0b3JlIDUKc3RvcmUgNApsb2FkIDUKYXNzZXJ0CmxvYWQgNApmcmFtZV9idXJ5IDAKcmV0c3ViCgovLyB1cGRhdGVfb3JhY2xlX2lkCnVwZGF0ZW9yYWNsZWlkXzE5Ogpwcm90byAxIDAKdHhuIFNlbmRlcgpnbG9iYWwgQ3JlYXRvckFkZHJlc3MKPT0KLy8gdW5hdXRob3JpemVkCmFzc2VydApieXRlYyA1IC8vICJnc18xMSIKZnJhbWVfZGlnIC0xCnR4bmFzIEFwcGxpY2F0aW9ucwphcHBfZ2xvYmFsX3B1dApyZXRzdWIKCi8vIHVwZGF0ZV9tYW5hZ2VyCnVwZGF0ZW1hbmFnZXJfMjA6CnByb3RvIDEgMAp0eG4gU2VuZGVyCmdsb2JhbCBDcmVhdG9yQWRkcmVzcwo9PQovLyB1bmF1dGhvcml6ZWQKYXNzZXJ0CmJ5dGVjXzIgLy8gImdzXzMiCmFwcF9nbG9iYWxfZ2V0CmZyYW1lX2RpZyAtMQohPQovLyBOZXcgbWFuYWdlciBjYW5ub3QgYmUgdGhlIHNhbWUgYXMgdGhlIG9sZCBtYW5hZ2VyCmFzc2VydApieXRlY18yIC8vICJnc18zIgpmcmFtZV9kaWcgLTEKYXBwX2dsb2JhbF9wdXQKcmV0c3ViCgovLyB1cGRhdGVfcHJpY2UKdXBkYXRlcHJpY2VfMjE6CnByb3RvIDEgMAp0eG4gU2VuZGVyCmJ5dGVjXzIgLy8gImdzXzMiCmFwcF9nbG9iYWxfZ2V0Cj09Ci8vIHVuYXV0aG9yaXplZAphc3NlcnQKYnl0ZWMgNiAvLyAiZ3NfNCIKZnJhbWVfZGlnIC0xCmFwcF9nbG9iYWxfcHV0CnJldHN1YgoKLy8gdXBkYXRlX2xpZmVjeWNsZQp1cGRhdGVsaWZlY3ljbGVfMjI6CnByb3RvIDEgMAp0eG4gU2VuZGVyCmJ5dGVjXzIgLy8gImdzXzMiCmFwcF9nbG9iYWxfZ2V0Cj09Ci8vIHVuYXV0aG9yaXplZAphc3NlcnQKZnJhbWVfZGlnIC0xCmludGNfMCAvLyAwCj09CmZyYW1lX2RpZyAtMQppbnRjXzEgLy8gMQo9PQp8fAovLyBJbnZhbGlkIGxpZmVjeWNsZSBzdGF0ZQphc3NlcnQKYnl0ZWMgNyAvLyAiZ3NfOSIKYXBwX2dsb2JhbF9nZXQKZnJhbWVfZGlnIC0xCiE9Ci8vIFN1YnNjcmlwdGlvbiBwcm9kdWN0IGlzIGFscmVhZHkgc2V0IHRvIHNhbWUgc3RhdGUKYXNzZXJ0CmJ5dGVjIDcgLy8gImdzXzkiCmZyYW1lX2RpZyAtMQphcHBfZ2xvYmFsX3B1dApyZXRzdWIKCi8vIGlzX2Rpc2NvdW50X2V4cGlyZWQKaXNkaXNjb3VudGV4cGlyZWRfMjM6CnByb3RvIDAgMQppbnRjXzAgLy8gMApieXRlY18wIC8vICIiCmludGNfMCAvLyAwCmJ5dGVjXzEgLy8gImJfZCIKYm94X2xlbgpzdG9yZSA3CnN0b3JlIDYKbG9hZCA3CmJueiBpc2Rpc2NvdW50ZXhwaXJlZF8yM19sMgppbnRjXzEgLy8gMQpmcmFtZV9idXJ5IDAKYiBpc2Rpc2NvdW50ZXhwaXJlZF8yM19sNwppc2Rpc2NvdW50ZXhwaXJlZF8yM19sMjoKYnl0ZWNfMSAvLyAiYl9kIgpib3hfZ2V0CnN0b3JlIDkKc3RvcmUgOApsb2FkIDkKYXNzZXJ0CmxvYWQgOApmcmFtZV9idXJ5IDEKZnJhbWVfZGlnIDEKcHVzaGludCAxNiAvLyAxNgpleHRyYWN0X3VpbnQ2NApmcmFtZV9idXJ5IDIKZnJhbWVfZGlnIDIKaW50Y18wIC8vIDAKPT0KYm56IGlzZGlzY291bnRleHBpcmVkXzIzX2w2CmZyYW1lX2RpZyAyCmdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKPgpibnogaXNkaXNjb3VudGV4cGlyZWRfMjNfbDUKaW50Y18xIC8vIDEKZnJhbWVfYnVyeSAwCmIgaXNkaXNjb3VudGV4cGlyZWRfMjNfbDcKaXNkaXNjb3VudGV4cGlyZWRfMjNfbDU6CmludGNfMCAvLyAwCmZyYW1lX2J1cnkgMApiIGlzZGlzY291bnRleHBpcmVkXzIzX2w3CmlzZGlzY291bnRleHBpcmVkXzIzX2w2OgppbnRjXzAgLy8gMApmcmFtZV9idXJ5IDAKaXNkaXNjb3VudGV4cGlyZWRfMjNfbDc6CnJldHN1YgoKLy8gY3JlYXRlX2Rpc2NvdW50CmNyZWF0ZWRpc2NvdW50XzI0Ogpwcm90byA0IDAKaW50Y18wIC8vIDAKZHVwbiAyCmJ5dGVjXzAgLy8gIiIKaW50Y18wIC8vIDAKZHVwCmJ5dGVjXzAgLy8gIiIKZHVwCnR4biBTZW5kZXIKYnl0ZWNfMiAvLyAiZ3NfMyIKYXBwX2dsb2JhbF9nZXQKPT0KLy8gdW5hdXRob3JpemVkCmFzc2VydApmcmFtZV9kaWcgLTEKZ3R4bnMgVHlwZUVudW0KaW50Y18xIC8vIHBheQo9PQpmcmFtZV9kaWcgLTEKZ3R4bnMgVHlwZUVudW0KaW50Y18zIC8vIGFwcGwKPT0KfHwKYm56IGNyZWF0ZWRpc2NvdW50XzI0X2wxMApmcmFtZV9kaWcgLTEKZ3R4bnMgVHlwZUVudW0KaW50Y18yIC8vIGF4ZmVyCj09CmJueiBjcmVhdGVkaXNjb3VudF8yNF9sMwplcnIKY3JlYXRlZGlzY291bnRfMjRfbDM6CmZyYW1lX2RpZyAtMQpndHhucyBBc3NldENsb3NlVG8KZ2xvYmFsIFplcm9BZGRyZXNzCj09Ci8vIEFzc2V0VHJhbnNmZXJUcmFuc2FjdGlvbiBoYXMgaW5zZWN1cmUgZmllbGRzCmFzc2VydApmcmFtZV9kaWcgLTEKZ3R4bnMgUmVrZXlUbwpnbG9iYWwgWmVyb0FkZHJlc3MKPT0KLy8gQXNzZXRUcmFuc2ZlclRyYW5zYWN0aW9uIGhhcyBpbnNlY3VyZSBmaWVsZHMKYXNzZXJ0CmNyZWF0ZWRpc2NvdW50XzI0X2w0OgpmcmFtZV9kaWcgLTQKaW50Y18wIC8vIDAKPT0KYm56IGNyZWF0ZWRpc2NvdW50XzI0X2w5CmZyYW1lX2RpZyAtMwppbnRjXzAgLy8gMApjYWxsc3ViIGlubmVyY29tcHV0ZXByaWNlXzEwCjw9Ci8vIERpc2NvdW50IGFtb3VudCBjYW5ub3QgZXhjZWVkIGFjdHVhbCBwcmljZQphc3NlcnQKY3JlYXRlZGlzY291bnRfMjRfbDY6CmZyYW1lX2RpZyAtMQpndHhucyBTZW5kZXIKYnl0ZWNfMiAvLyAiZ3NfMyIKYXBwX2dsb2JhbF9nZXQKPT0KLy8gRmVlIHR4biBzZW50IGJ5IHRoZSBtYW5hZ2VyIG11c3QgYmUgb2YgdGhlIHJpZ2h0IGFtb3VudAphc3NlcnQKZnJhbWVfZGlnIC0xCmd0eG5zIEFtb3VudAppbnRjIDYgLy8gMjE3MDAKPT0KLy8gRmVlIHR4biBzZW50IGJ5IHRoZSBtYW5hZ2VyIG11c3QgYmUgb2YgdGhlIHJpZ2h0IGFtb3VudAphc3NlcnQKZnJhbWVfZGlnIC0xCmd0eG5zIFJlY2VpdmVyCmdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCj09Ci8vIEZlZSB0eG4gc2VudCBieSB0aGUgbWFuYWdlciBtdXN0IGJlIG9mIHRoZSByaWdodCBhbW91bnQKYXNzZXJ0CmZyYW1lX2RpZyAtNAppbnRjXzAgLy8gMAo9PQpmcmFtZV9kaWcgLTQKaW50Y18xIC8vIDEKPT0KfHwKLy8gRGlzY291bnQgdHlwZSBtdXN0IGJlIGVpdGhlciBwZXJjZW50YWdlIG9yIGFtb3VudAphc3NlcnQKYnl0ZWNfMSAvLyAiYl9kIgpib3hfbGVuCnN0b3JlIDExCnN0b3JlIDEwCmxvYWQgMTEKaW50Y18xIC8vIDEKIT0KLy8gRGlzY291bnQgYWxyZWFkeSBleGlzdHMsIGRlbGV0ZSBvbmUgZmlyc3QKYXNzZXJ0Cmdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKZnJhbWVfYnVyeSAwCmZyYW1lX2RpZyAtMgppbnRjXzAgLy8gMAo+CmJueiBjcmVhdGVkaXNjb3VudF8yNF9sOAppbnRjXzAgLy8gMApiIGNyZWF0ZWRpc2NvdW50XzI0X2wxMQpjcmVhdGVkaXNjb3VudF8yNF9sODoKZnJhbWVfZGlnIDAKZnJhbWVfZGlnIC0yCisKYiBjcmVhdGVkaXNjb3VudF8yNF9sMTEKY3JlYXRlZGlzY291bnRfMjRfbDk6CmZyYW1lX2RpZyAtMwpwdXNoaW50IDEwMCAvLyAxMDAKPD0KLy8gUGVyY2VudGFnZSBkaXNjb3VudCBtdXN0IGJlIDw9IDEwMAphc3NlcnQKYiBjcmVhdGVkaXNjb3VudF8yNF9sNgpjcmVhdGVkaXNjb3VudF8yNF9sMTA6CmZyYW1lX2RpZyAtMQpndHhucyBDbG9zZVJlbWFpbmRlclRvCmdsb2JhbCBaZXJvQWRkcmVzcwo9PQovLyBQYXltZW50VHJhbnNhY3Rpb24gaGFzIGluc2VjdXJlIGZpZWxkcwphc3NlcnQKZnJhbWVfZGlnIC0xCmd0eG5zIFJla2V5VG8KZ2xvYmFsIFplcm9BZGRyZXNzCj09Ci8vIFBheW1lbnRUcmFuc2FjdGlvbiBoYXMgaW5zZWN1cmUgZmllbGRzCmFzc2VydApiIGNyZWF0ZWRpc2NvdW50XzI0X2w0CmNyZWF0ZWRpc2NvdW50XzI0X2wxMToKZnJhbWVfYnVyeSAxCmludGNfMCAvLyAwCmZyYW1lX2J1cnkgMgpmcmFtZV9kaWcgLTQKaXRvYgpmcmFtZV9kaWcgLTMKaXRvYgpjb25jYXQKZnJhbWVfZGlnIDEKaXRvYgpjb25jYXQKZnJhbWVfZGlnIDAKaXRvYgpjb25jYXQKZnJhbWVfZGlnIDIKaXRvYgpjb25jYXQKZnJhbWVfYnVyeSAzCmJ5dGVjXzEgLy8gImJfZCIKYm94X2RlbApwb3AKYnl0ZWNfMSAvLyAiYl9kIgpmcmFtZV9kaWcgMwpib3hfcHV0CnJldHN1YgoKLy8gZGVsZXRlX2Rpc2NvdW50CmRlbGV0ZWRpc2NvdW50XzI1Ogpwcm90byAwIDAKdHhuIFNlbmRlcgpieXRlY18yIC8vICJnc18zIgphcHBfZ2xvYmFsX2dldAo9PQovLyB1bmF1dGhvcml6ZWQKYXNzZXJ0CmJ5dGVjXzEgLy8gImJfZCIKYm94X2xlbgpzdG9yZSAyMQpzdG9yZSAyMApsb2FkIDIxCmludGNfMSAvLyAxCj09Ci8vIERpc2NvdW50IGRvZXMgbm90IGV4aXN0CmFzc2VydAppdHhuX2JlZ2luCmdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCml0eG5fZmllbGQgU2VuZGVyCmludGNfMSAvLyBwYXkKaXR4bl9maWVsZCBUeXBlRW51bQp0eG4gU2VuZGVyCml0eG5fZmllbGQgUmVjZWl2ZXIKaW50YyA2IC8vIDIxNzAwCml0eG5fZmllbGQgQW1vdW50CmludGNfMCAvLyAwCml0eG5fZmllbGQgRmVlCml0eG5fc3VibWl0CmJ5dGVjXzEgLy8gImJfZCIKYm94X2RlbApwb3AKcmV0c3ViCgovLyBjb21wdXRlX3ByaWNlCmNvbXB1dGVwcmljZV8yNjoKcHJvdG8gMSAxCmludGNfMCAvLyAwCmZyYW1lX2RpZyAtMQpjYWxsc3ViIGlubmVyY29tcHV0ZXByaWNlXzEwCmZyYW1lX2J1cnkgMApyZXRzdWIKCi8vIGNyZWF0ZV9zdWJzY3JpcHRpb24KY3JlYXRlc3Vic2NyaXB0aW9uXzI3Ogpwcm90byA2IDEKaW50Y18wIC8vIDAKZHVwbiA1CmJ5dGVjXzAgLy8gIiIKaW50Y18wIC8vIDAKZHVwCmJ5dGVjXzAgLy8gIiIKaW50Y18wIC8vIDAKZHVwCmJ5dGVjXzAgLy8gIiIKZHVwCmZyYW1lX2RpZyAtMwpndHhucyBUeXBlRW51bQppbnRjXzEgLy8gcGF5Cj09CmZyYW1lX2RpZyAtMwpndHhucyBUeXBlRW51bQppbnRjXzMgLy8gYXBwbAo9PQp8fApibnogY3JlYXRlc3Vic2NyaXB0aW9uXzI3X2wyMQpmcmFtZV9kaWcgLTMKZ3R4bnMgVHlwZUVudW0KaW50Y18yIC8vIGF4ZmVyCj09CmJueiBjcmVhdGVzdWJzY3JpcHRpb25fMjdfbDMKZXJyCmNyZWF0ZXN1YnNjcmlwdGlvbl8yN19sMzoKZnJhbWVfZGlnIC0zCmd0eG5zIEFzc2V0Q2xvc2VUbwpnbG9iYWwgWmVyb0FkZHJlc3MKPT0KLy8gQXNzZXRUcmFuc2ZlclRyYW5zYWN0aW9uIGhhcyBpbnNlY3VyZSBmaWVsZHMKYXNzZXJ0CmZyYW1lX2RpZyAtMwpndHhucyBSZWtleVRvCmdsb2JhbCBaZXJvQWRkcmVzcwo9PQovLyBBc3NldFRyYW5zZmVyVHJhbnNhY3Rpb24gaGFzIGluc2VjdXJlIGZpZWxkcwphc3NlcnQKY3JlYXRlc3Vic2NyaXB0aW9uXzI3X2w0OgpmcmFtZV9kaWcgLTEKZ3R4bnMgVHlwZUVudW0KaW50Y18xIC8vIHBheQo9PQpmcmFtZV9kaWcgLTEKZ3R4bnMgVHlwZUVudW0KaW50Y18zIC8vIGFwcGwKPT0KfHwKYm56IGNyZWF0ZXN1YnNjcmlwdGlvbl8yN19sMjAKZnJhbWVfZGlnIC0xCmd0eG5zIFR5cGVFbnVtCmludGNfMiAvLyBheGZlcgo9PQpibnogY3JlYXRlc3Vic2NyaXB0aW9uXzI3X2w3CmVycgpjcmVhdGVzdWJzY3JpcHRpb25fMjdfbDc6CmZyYW1lX2RpZyAtMQpndHhucyBBc3NldENsb3NlVG8KZ2xvYmFsIFplcm9BZGRyZXNzCj09Ci8vIEFzc2V0VHJhbnNmZXJUcmFuc2FjdGlvbiBoYXMgaW5zZWN1cmUgZmllbGRzCmFzc2VydApmcmFtZV9kaWcgLTEKZ3R4bnMgUmVrZXlUbwpnbG9iYWwgWmVyb0FkZHJlc3MKPT0KLy8gQXNzZXRUcmFuc2ZlclRyYW5zYWN0aW9uIGhhcyBpbnNlY3VyZSBmaWVsZHMKYXNzZXJ0CmNyZWF0ZXN1YnNjcmlwdGlvbl8yN19sODoKZnJhbWVfZGlnIC0yCmd0eG5zIFR5cGVFbnVtCmludGNfMSAvLyBwYXkKPT0KZnJhbWVfZGlnIC0yCmd0eG5zIFR5cGVFbnVtCmludGNfMyAvLyBhcHBsCj09Cnx8CmJueiBjcmVhdGVzdWJzY3JpcHRpb25fMjdfbDE5CmZyYW1lX2RpZyAtMgpndHhucyBUeXBlRW51bQppbnRjXzIgLy8gYXhmZXIKPT0KYm56IGNyZWF0ZXN1YnNjcmlwdGlvbl8yN19sMTEKZXJyCmNyZWF0ZXN1YnNjcmlwdGlvbl8yN19sMTE6CmZyYW1lX2RpZyAtMgpndHhucyBBc3NldENsb3NlVG8KZ2xvYmFsIFplcm9BZGRyZXNzCj09Ci8vIEFzc2V0VHJhbnNmZXJUcmFuc2FjdGlvbiBoYXMgaW5zZWN1cmUgZmllbGRzCmFzc2VydApmcmFtZV9kaWcgLTIKZ3R4bnMgUmVrZXlUbwpnbG9iYWwgWmVyb0FkZHJlc3MKPT0KLy8gQXNzZXRUcmFuc2ZlclRyYW5zYWN0aW9uIGhhcyBpbnNlY3VyZSBmaWVsZHMKYXNzZXJ0CmNyZWF0ZXN1YnNjcmlwdGlvbl8yN19sMTI6CmJ5dGVjIDcgLy8gImdzXzkiCmFwcF9nbG9iYWxfZ2V0CmludGNfMCAvLyAwCj09Ci8vIFN1YnNjcmlwdGlvbiBwcm9kdWN0IGlzIGRpc2FibGVkCmFzc2VydApieXRlYyA4IC8vICJnc18xNCIKYXBwX2dsb2JhbF9nZXQKY2FsbHN1YiBpbm5lcmNvbXB1dGVleHBpcmF0aW9uXzcKZnJhbWVfYnVyeSAxCmJ5dGVjIDEyIC8vICJnc184IgphcHBfZ2xvYmFsX2dldApmcmFtZV9idXJ5IDIKaW50Y18wIC8vIDAKZnJhbWVfYnVyeSAzCmludGNfMCAvLyAwCmZyYW1lX2J1cnkgNAppbnRjXzEgLy8gMQpjYWxsc3ViIGlubmVyY29tcHV0ZXByaWNlXzEwCmZyYW1lX2J1cnkgNQpmcmFtZV9kaWcgLTQKdHhuYXMgQXBwbGljYXRpb25zCmJ5dGVjIDUgLy8gImdzXzExIgphcHBfZ2xvYmFsX2dldAo9PQovLyBPUkFDTEUgSUQgbXVzdCBtYXRjaAphc3NlcnQKZnJhbWVfZGlnIC0zCmd0eG5zIFNlbmRlcgpmcmFtZV9kaWcgLTIKZ3R4bnMgU2VuZGVyCj09Ci8vIFN1YnNjcmliZXIgYWNjb3VudCBtdXN0IG1hdGNoIGZlZSBhbmQgcGF5IHR4biBzZW5kZXIKYXNzZXJ0CmJ5dGVjIDUgLy8gImdzXzExIgphcHBfZ2xvYmFsX2dldApwdXNoYnl0ZXMgMHg2MTY0NmQ2OTZlIC8vICJhZG1pbiIKYXBwX2dsb2JhbF9nZXRfZXgKc3RvcmUgMjMKc3RvcmUgMjIKZnJhbWVfZGlnIC0yCmd0eG5zIEFtb3VudApieXRlYyA1IC8vICJnc18xMSIKYXBwX2dsb2JhbF9nZXQKcHVzaGludCAxMCAvLyAxMApjYWxsc3ViIGlubmVydXNkaW5taWNyb2FsZ29fMgo9PQpieXRlYyA2IC8vICJnc180IgphcHBfZ2xvYmFsX2dldAppbnRjXzAgLy8gMAo9PQpmcmFtZV9kaWcgLTIKZ3R4bnMgQW1vdW50CmludGNfMCAvLyAwCj09CiYmCnx8Ci8vIFBsYXRmb3JtIGZlZSBwYXJhbXMgbWlzbWF0Y2gKYXNzZXJ0CmZyYW1lX2RpZyAtMgpndHhucyBSZWNlaXZlcgpsb2FkIDIyCj09Ci8vIFBsYXRmb3JtIGZlZSBwYXJhbXMgbWlzbWF0Y2gKYXNzZXJ0CmZyYW1lX2RpZyAtNQp0eG5hcyBBcHBsaWNhdGlvbnMKYnl0ZWMgMTggLy8gIm1hbmFnZXIiCmFwcF9nbG9iYWxfZ2V0X2V4CnN0b3JlIDI0CmJ5dGVjXzIgLy8gImdzXzMiCmFwcF9nbG9iYWxfZ2V0Cj09Ci8vIExvY2tlciBkb2VzIG5vdCBiZWxvbmcgdG8gbWFuYWdlciBvZiB0aGlzIFByb2R1Y3QKYXNzZXJ0CmZyYW1lX2RpZyAtNQp0eG5hcyBBcHBsaWNhdGlvbnMKYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwpzdG9yZSAyNgpzdG9yZSAyNQpmcmFtZV9kaWcgLTEKZ3R4bnMgVHlwZUVudW0KaW50Y18xIC8vIHBheQo9PQpmcmFtZV9kaWcgLTEKZ3R4bnMgQW1vdW50CmZyYW1lX2RpZyA1Cj09CiYmCmZyYW1lX2RpZyAtMQpndHhucyBSZWNlaXZlcgpsb2FkIDI1Cj09CiYmCmZyYW1lX2RpZyAtMQpndHhucyBUeXBlRW51bQppbnRjXzIgLy8gYXhmZXIKPT0KZnJhbWVfZGlnIC0xCmd0eG5zIEFzc2V0QW1vdW50CmZyYW1lX2RpZyA1Cj09CiYmCmZyYW1lX2RpZyAtMQpndHhucyBBc3NldFJlY2VpdmVyCmxvYWQgMjUKPT0KJiYKfHwKLy8gU3Vic2NyaXB0aW9uIHBheW1lbnQgbXVzdCBiZSBzZW5kIHRvIGxvY2tlciB3aXRoIHJpZ2h0IHBheQphc3NlcnQKYnl0ZWMgOSAvLyAiZ3NfNiIKYXBwX2dsb2JhbF9nZXQKaW50Y18wIC8vIDAKPgpibnogY3JlYXRlc3Vic2NyaXB0aW9uXzI3X2wxOApjcmVhdGVzdWJzY3JpcHRpb25fMjdfbDEzOgpmcmFtZV9kaWcgLTYKYm94X2xlbgpzdG9yZSAyOApzdG9yZSAyNwpsb2FkIDI4CmJueiBjcmVhdGVzdWJzY3JpcHRpb25fMjdfbDE1CmZyYW1lX2RpZyAtMwpndHhucyBBbW91bnQKaW50YyA3IC8vIDMxMzAwCmludGMgNCAvLyAxMDAwMDAKKwo9PQovLyBGZWUgdHhuIG11c3QgYmUgb2YgdGhlIHJpZ2h0IGFtb3VudAphc3NlcnQKYnl0ZWNfMyAvLyAiZ3NfNSIKYnl0ZWNfMyAvLyAiZ3NfNSIKYXBwX2dsb2JhbF9nZXQKaW50Y18xIC8vIDEKKwphcHBfZ2xvYmFsX3B1dApieXRlYyAxMCAvLyAiZ3NfMTIiCmFwcF9nbG9iYWxfZ2V0CnB1c2hieXRlcyAweDJkIC8vICItIgpjb25jYXQKcHVzaGJ5dGVzIDB4MjMgLy8gIiMiCmNvbmNhdApieXRlY18zIC8vICJnc181IgphcHBfZ2xvYmFsX2dldApjYWxsc3ViIGl0b2FfMQpjb25jYXQKYnl0ZWMgMTAgLy8gImdzXzEyIgphcHBfZ2xvYmFsX2dldApieXRlYyAxMSAvLyAiZ3NfMTMiCmFwcF9nbG9iYWxfZ2V0CmNhbGxzdWIgaW5uZXJjcmVhdGVhc3NldF8zCmZyYW1lX2J1cnkgMwpnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCmZyYW1lX2J1cnkgNApiIGNyZWF0ZXN1YnNjcmlwdGlvbl8yN19sMjIKY3JlYXRlc3Vic2NyaXB0aW9uXzI3X2wxNToKZnJhbWVfZGlnIC0zCmd0eG5zIEFtb3VudAppbnRjXzAgLy8gMAo9PQovLyBGZWUgdHhuIG11c3QgYmUgb2YgdGhlIHJpZ2h0IGFtb3VudAphc3NlcnQKZnJhbWVfZGlnIC02CmJveF9nZXQKc3RvcmUgMzAKc3RvcmUgMjkKbG9hZCAzMAphc3NlcnQKbG9hZCAyOQpmcmFtZV9idXJ5IDYKZnJhbWVfZGlnIDYKcHVzaGludCAyNCAvLyAyNApleHRyYWN0X3VpbnQ2NApmcmFtZV9idXJ5IDcKZnJhbWVfZGlnIDcKaW50Y18wIC8vIDAKIT0KYm56IGNyZWF0ZXN1YnNjcmlwdGlvbl8yN19sMTcKaW50Y18wIC8vIDAKcmV0dXJuCmNyZWF0ZXN1YnNjcmlwdGlvbl8yN19sMTc6CmZyYW1lX2RpZyA3Cmdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKPAovLyBTdWJzY3JpcHRpb24gc3RpbGwgYWN0aXZlCmFzc2VydApmcmFtZV9kaWcgNgppbnRjXzAgLy8gMApleHRyYWN0X3VpbnQ2NApmcmFtZV9idXJ5IDMKZnJhbWVfZGlnIDYKcHVzaGludCAxNiAvLyAxNgpleHRyYWN0X3VpbnQ2NApmcmFtZV9idXJ5IDQKYiBjcmVhdGVzdWJzY3JpcHRpb25fMjdfbDIyCmNyZWF0ZXN1YnNjcmlwdGlvbl8yN19sMTg6CmJ5dGVjXzMgLy8gImdzXzUiCmFwcF9nbG9iYWxfZ2V0CmludGNfMSAvLyAxCisKYnl0ZWMgOSAvLyAiZ3NfNiIKYXBwX2dsb2JhbF9nZXQKPD0KLy8gTWF4IGl0ZW1zIHJlYWNoZWQKYXNzZXJ0CmIgY3JlYXRlc3Vic2NyaXB0aW9uXzI3X2wxMwpjcmVhdGVzdWJzY3JpcHRpb25fMjdfbDE5OgpmcmFtZV9kaWcgLTIKZ3R4bnMgQ2xvc2VSZW1haW5kZXJUbwpnbG9iYWwgWmVyb0FkZHJlc3MKPT0KLy8gUGF5bWVudFRyYW5zYWN0aW9uIGhhcyBpbnNlY3VyZSBmaWVsZHMKYXNzZXJ0CmZyYW1lX2RpZyAtMgpndHhucyBSZWtleVRvCmdsb2JhbCBaZXJvQWRkcmVzcwo9PQovLyBQYXltZW50VHJhbnNhY3Rpb24gaGFzIGluc2VjdXJlIGZpZWxkcwphc3NlcnQKYiBjcmVhdGVzdWJzY3JpcHRpb25fMjdfbDEyCmNyZWF0ZXN1YnNjcmlwdGlvbl8yN19sMjA6CmZyYW1lX2RpZyAtMQpndHhucyBDbG9zZVJlbWFpbmRlclRvCmdsb2JhbCBaZXJvQWRkcmVzcwo9PQovLyBQYXltZW50VHJhbnNhY3Rpb24gaGFzIGluc2VjdXJlIGZpZWxkcwphc3NlcnQKZnJhbWVfZGlnIC0xCmd0eG5zIFJla2V5VG8KZ2xvYmFsIFplcm9BZGRyZXNzCj09Ci8vIFBheW1lbnRUcmFuc2FjdGlvbiBoYXMgaW5zZWN1cmUgZmllbGRzCmFzc2VydApiIGNyZWF0ZXN1YnNjcmlwdGlvbl8yN19sOApjcmVhdGVzdWJzY3JpcHRpb25fMjdfbDIxOgpmcmFtZV9kaWcgLTMKZ3R4bnMgQ2xvc2VSZW1haW5kZXJUbwpnbG9iYWwgWmVyb0FkZHJlc3MKPT0KLy8gUGF5bWVudFRyYW5zYWN0aW9uIGhhcyBpbnNlY3VyZSBmaWVsZHMKYXNzZXJ0CmZyYW1lX2RpZyAtMwpndHhucyBSZWtleVRvCmdsb2JhbCBaZXJvQWRkcmVzcwo9PQovLyBQYXltZW50VHJhbnNhY3Rpb24gaGFzIGluc2VjdXJlIGZpZWxkcwphc3NlcnQKYiBjcmVhdGVzdWJzY3JpcHRpb25fMjdfbDQKY3JlYXRlc3Vic2NyaXB0aW9uXzI3X2wyMjoKYnl0ZWMgOCAvLyAiZ3NfMTQiCmFwcF9nbG9iYWxfZ2V0CmZyYW1lX2J1cnkgOApmcmFtZV9kaWcgMwppdG9iCmZyYW1lX2RpZyAyCml0b2IKY29uY2F0CmZyYW1lX2RpZyA0Cml0b2IKY29uY2F0CmZyYW1lX2RpZyAxCml0b2IKY29uY2F0CmZyYW1lX2RpZyA4Cml0b2IKY29uY2F0CmZyYW1lX2J1cnkgOQpmcmFtZV9kaWcgLTYKYm94X2RlbApwb3AKZnJhbWVfZGlnIC02CmZyYW1lX2RpZyA5CmJveF9wdXQKZnJhbWVfZGlnIDMKZnJhbWVfYnVyeSAwCnJldHN1YgoKLy8gaXNfc3Vic2NyaWJlcgppc3N1YnNjcmliZXJfMjg6CnByb3RvIDEgMQppbnRjXzAgLy8gMApieXRlY18wIC8vICIiCmludGNfMCAvLyAwCmZyYW1lX2RpZyAtMQpib3hfbGVuCnN0b3JlIDMyCnN0b3JlIDMxCmxvYWQgMzIKYm56IGlzc3Vic2NyaWJlcl8yOF9sMgppbnRjXzAgLy8gMApmcmFtZV9idXJ5IDAKYiBpc3N1YnNjcmliZXJfMjhfbDUKaXNzdWJzY3JpYmVyXzI4X2wyOgpmcmFtZV9kaWcgLTEKYm94X2dldApzdG9yZSAzNApzdG9yZSAzMwpsb2FkIDM0CmFzc2VydApsb2FkIDMzCmZyYW1lX2J1cnkgMQpmcmFtZV9kaWcgMQpwdXNoaW50IDI0IC8vIDI0CmV4dHJhY3RfdWludDY0CmZyYW1lX2J1cnkgMgpmcmFtZV9kaWcgMgppbnRjXzAgLy8gMAo9PQpibnogaXNzdWJzY3JpYmVyXzI4X2w0CmZyYW1lX2RpZyAyCmdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKPgpmcmFtZV9idXJ5IDAKYiBpc3N1YnNjcmliZXJfMjhfbDUKaXNzdWJzY3JpYmVyXzI4X2w0OgppbnRjXzEgLy8gMQpmcmFtZV9idXJ5IDAKaXNzdWJzY3JpYmVyXzI4X2w1OgpyZXRzdWIKCi8vIGNsYWltX3N1YnNjcmlwdGlvbgpjbGFpbXN1YnNjcmlwdGlvbl8yOToKcHJvdG8gMSAwCnR4biBTZW5kZXIKZnJhbWVfZGlnIC0xCnR4bmFzIEFzc2V0cwphc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKc3RvcmUgMzYKc3RvcmUgMzUKbG9hZCAzNgovLyBTdWJzY3JpYmVyIG5vdCBvcHRlZC1pbiBmb3IgU3Vic2NyaXB0aW9uIE5GVAphc3NlcnQKZnJhbWVfZGlnIC0xCmdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCnR4biBTZW5kZXIKY2FsbHN1YiBpbm5lcnRyYW5zZmVyYXNzZXRfNApyZXRzdWIKCi8vIHRyYW5zZmVyX3N1YnNjcmlwdGlvbgp0cmFuc2ZlcnN1YnNjcmlwdGlvbl8zMDoKcHJvdG8gMiAwCmJ5dGVjXzAgLy8gIiIKdHhuIFNlbmRlcgpib3hfbGVuCnN0b3JlIDM4CnN0b3JlIDM3CmxvYWQgMzgKLy8gQ3VycmVudCBhZGRyZXNzIG5vdCBzdWJzY3JpYmVkCmFzc2VydAp0eG4gU2VuZGVyCmZyYW1lX2RpZyAtMQp0eG5hcyBBc3NldHMKYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCnN0b3JlIDQwCnN0b3JlIDM5CmxvYWQgNDAKbG9hZCAzOQppbnRjXzAgLy8gMAo+CiYmCmJ6IHRyYW5zZmVyc3Vic2NyaXB0aW9uXzMwX2wyCmZyYW1lX2RpZyAtMQp0eG4gU2VuZGVyCmdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCmNhbGxzdWIgaW5uZXJ0cmFuc2ZlcmFzc2V0XzQKdHJhbnNmZXJzdWJzY3JpcHRpb25fMzBfbDI6CnR4biBTZW5kZXIKYm94X2dldApzdG9yZSA0MgpzdG9yZSA0MQpsb2FkIDQyCmFzc2VydApsb2FkIDQxCmZyYW1lX2J1cnkgMApmcmFtZV9kaWcgLTIKYm94X2RlbApwb3AKZnJhbWVfZGlnIC0yCmZyYW1lX2RpZyAwCmJveF9wdXQKdHhuIFNlbmRlcgpib3hfZGVsCnBvcApyZXRzdWIKCi8vIGRlbGV0ZV9zdWJzY3JpcHRpb24KZGVsZXRlc3Vic2NyaXB0aW9uXzMxOgpwcm90byAxIDEKaW50Y18wIC8vIDAKYnl0ZWNfMCAvLyAiIgp0eG4gU2VuZGVyCmJveF9sZW4Kc3RvcmUgNDUKc3RvcmUgNDMKbG9hZCA0NQovLyBOb3Qgc3Vic2NyaWJlZAphc3NlcnQKdHhuIFNlbmRlcgpmcmFtZV9idXJ5IDEKZnJhbWVfZGlnIDEKbGVuCnB1c2hpbnQgMzIgLy8gMzIKPT0KYXNzZXJ0CmZyYW1lX2RpZyAxCmZyYW1lX2RpZyAtMQpjYWxsc3ViIGlubmVyZGVsZXRlc3Vic2NyaXB0aW9uXzYKaXR4bl9iZWdpbgpnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwppdHhuX2ZpZWxkIFNlbmRlcgppbnRjXzEgLy8gcGF5Cml0eG5fZmllbGQgVHlwZUVudW0KZnJhbWVfZGlnIDEKaXR4bl9maWVsZCBSZWNlaXZlcgppbnRjIDcgLy8gMzEzMDAKaW50YyA0IC8vIDEwMDAwMAorCml0eG5fZmllbGQgQW1vdW50CmludGNfMCAvLyAwCml0eG5fZmllbGQgRmVlCml0eG5fc3VibWl0CmZyYW1lX2RpZyAtMQp0eG5hcyBBc3NldHMKZnJhbWVfYnVyeSAwCnJldHN1YgoKLy8gY3JlYXRlX2Nhc3RlcgpjcmVhdGVjYXN0ZXJfMzI6CnByb3RvIDAgMApieXRlY18wIC8vICIiCmR1cG4gMgppbnRjXzAgLy8gMApkdXBuIDMKYnl0ZWNfMCAvLyAiIgpkdXAKaW50Y18wIC8vIDAKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQpmcmFtZV9idXJ5IDAKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgpmcmFtZV9idXJ5IDEKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwpmcmFtZV9idXJ5IDIKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNApidG9pCmZyYW1lX2J1cnkgMwp0eG5hIEFwcGxpY2F0aW9uQXJncyA1CmJ0b2kKZnJhbWVfYnVyeSA0CnR4bmEgQXBwbGljYXRpb25BcmdzIDYKYnRvaQpmcmFtZV9idXJ5IDUKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNwpidG9pCmZyYW1lX2J1cnkgNgp0eG5hIEFwcGxpY2F0aW9uQXJncyA4CmZyYW1lX2J1cnkgNwp0eG5hIEFwcGxpY2F0aW9uQXJncyA5CmZyYW1lX2J1cnkgOAp0eG5hIEFwcGxpY2F0aW9uQXJncyAxMApidG9pCmZyYW1lX2J1cnkgOQpmcmFtZV9kaWcgMApmcmFtZV9kaWcgMQpmcmFtZV9kaWcgMgpmcmFtZV9kaWcgMwpmcmFtZV9kaWcgNApmcmFtZV9kaWcgNQpmcmFtZV9kaWcgNgpmcmFtZV9kaWcgNwpmcmFtZV9kaWcgOApmcmFtZV9kaWcgOQpjYWxsc3ViIGNyZWF0ZV8xMQpyZXRzdWIKCi8vIGRlbGV0ZV9jYXN0ZXIKZGVsZXRlY2FzdGVyXzMzOgpwcm90byAwIDAKY2FsbHN1YiBkZWxldGVfMTUKcmV0c3ViCgovLyBnZXRfdmVyc2lvbl9jYXN0ZXIKZ2V0dmVyc2lvbmNhc3Rlcl8zNDoKcHJvdG8gMCAwCmJ5dGVjXzAgLy8gIiIKY2FsbHN1YiBnZXR2ZXJzaW9uXzE2CmZyYW1lX2J1cnkgMApieXRlYyA0IC8vIDB4MTUxZjdjNzUKZnJhbWVfZGlnIDAKY29uY2F0CmxvZwpyZXRzdWIKCi8vIGdldF9kaXNjb3VudF9jYXN0ZXIKZ2V0ZGlzY291bnRjYXN0ZXJfMzU6CnByb3RvIDAgMApieXRlY18wIC8vICIiCmNhbGxzdWIgZ2V0ZGlzY291bnRfMTcKZnJhbWVfYnVyeSAwCmJ5dGVjIDQgLy8gMHgxNTFmN2M3NQpmcmFtZV9kaWcgMApjb25jYXQKbG9nCnJldHN1YgoKLy8gZ2V0X3N1YnNjcmlwdGlvbl9jYXN0ZXIKZ2V0c3Vic2NyaXB0aW9uY2FzdGVyXzM2Ogpwcm90byAwIDAKYnl0ZWNfMCAvLyAiIgpkdXAKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQpmcmFtZV9idXJ5IDEKZnJhbWVfZGlnIDEKY2FsbHN1YiBnZXRzdWJzY3JpcHRpb25fMTgKZnJhbWVfYnVyeSAwCmJ5dGVjIDQgLy8gMHgxNTFmN2M3NQpmcmFtZV9kaWcgMApjb25jYXQKbG9nCnJldHN1YgoKLy8gdXBkYXRlX29yYWNsZV9pZF9jYXN0ZXIKdXBkYXRlb3JhY2xlaWRjYXN0ZXJfMzc6CnByb3RvIDAgMAppbnRjXzAgLy8gMAp0eG5hIEFwcGxpY2F0aW9uQXJncyAxCmludGNfMCAvLyAwCmdldGJ5dGUKZnJhbWVfYnVyeSAwCmZyYW1lX2RpZyAwCmNhbGxzdWIgdXBkYXRlb3JhY2xlaWRfMTkKcmV0c3ViCgovLyB1cGRhdGVfbWFuYWdlcl9jYXN0ZXIKdXBkYXRlbWFuYWdlcmNhc3Rlcl8zODoKcHJvdG8gMCAwCmJ5dGVjXzAgLy8gIiIKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQpmcmFtZV9idXJ5IDAKZnJhbWVfZGlnIDAKY2FsbHN1YiB1cGRhdGVtYW5hZ2VyXzIwCnJldHN1YgoKLy8gdXBkYXRlX3ByaWNlX2Nhc3Rlcgp1cGRhdGVwcmljZWNhc3Rlcl8zOToKcHJvdG8gMCAwCmludGNfMCAvLyAwCnR4bmEgQXBwbGljYXRpb25BcmdzIDEKYnRvaQpmcmFtZV9idXJ5IDAKZnJhbWVfZGlnIDAKY2FsbHN1YiB1cGRhdGVwcmljZV8yMQpyZXRzdWIKCi8vIHVwZGF0ZV9saWZlY3ljbGVfY2FzdGVyCnVwZGF0ZWxpZmVjeWNsZWNhc3Rlcl80MDoKcHJvdG8gMCAwCmludGNfMCAvLyAwCnR4bmEgQXBwbGljYXRpb25BcmdzIDEKYnRvaQpmcmFtZV9idXJ5IDAKZnJhbWVfZGlnIDAKY2FsbHN1YiB1cGRhdGVsaWZlY3ljbGVfMjIKcmV0c3ViCgovLyBpc19kaXNjb3VudF9leHBpcmVkX2Nhc3Rlcgppc2Rpc2NvdW50ZXhwaXJlZGNhc3Rlcl80MToKcHJvdG8gMCAwCmludGNfMCAvLyAwCmNhbGxzdWIgaXNkaXNjb3VudGV4cGlyZWRfMjMKZnJhbWVfYnVyeSAwCmJ5dGVjIDQgLy8gMHgxNTFmN2M3NQpmcmFtZV9kaWcgMAppdG9iCmNvbmNhdApsb2cKcmV0c3ViCgovLyBjcmVhdGVfZGlzY291bnRfY2FzdGVyCmNyZWF0ZWRpc2NvdW50Y2FzdGVyXzQyOgpwcm90byAwIDAKaW50Y18wIC8vIDAKZHVwbiAzCnR4bmEgQXBwbGljYXRpb25BcmdzIDEKYnRvaQpmcmFtZV9idXJ5IDAKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgpidG9pCmZyYW1lX2J1cnkgMQp0eG5hIEFwcGxpY2F0aW9uQXJncyAzCmJ0b2kKZnJhbWVfYnVyeSAyCnR4biBHcm91cEluZGV4CmludGNfMSAvLyAxCi0KZnJhbWVfYnVyeSAzCmZyYW1lX2RpZyAzCmd0eG5zIFR5cGVFbnVtCmludGNfMSAvLyBwYXkKPT0KYXNzZXJ0CmZyYW1lX2RpZyAwCmZyYW1lX2RpZyAxCmZyYW1lX2RpZyAyCmZyYW1lX2RpZyAzCmNhbGxzdWIgY3JlYXRlZGlzY291bnRfMjQKcmV0c3ViCgovLyBkZWxldGVfZGlzY291bnRfY2FzdGVyCmRlbGV0ZWRpc2NvdW50Y2FzdGVyXzQzOgpwcm90byAwIDAKY2FsbHN1YiBkZWxldGVkaXNjb3VudF8yNQpyZXRzdWIKCi8vIGNvbXB1dGVfcHJpY2VfY2FzdGVyCmNvbXB1dGVwcmljZWNhc3Rlcl80NDoKcHJvdG8gMCAwCmludGNfMCAvLyAwCmR1cAp0eG5hIEFwcGxpY2F0aW9uQXJncyAxCmludGNfMCAvLyAwCnB1c2hpbnQgOCAvLyA4CioKZ2V0Yml0CmZyYW1lX2J1cnkgMQpmcmFtZV9kaWcgMQpjYWxsc3ViIGNvbXB1dGVwcmljZV8yNgpmcmFtZV9idXJ5IDAKYnl0ZWMgNCAvLyAweDE1MWY3Yzc1CmZyYW1lX2RpZyAwCml0b2IKY29uY2F0CmxvZwpyZXRzdWIKCi8vIGNyZWF0ZV9zdWJzY3JpcHRpb25fY2FzdGVyCmNyZWF0ZXN1YnNjcmlwdGlvbmNhc3Rlcl80NToKcHJvdG8gMCAwCmludGNfMCAvLyAwCmJ5dGVjXzAgLy8gIiIKaW50Y18wIC8vIDAKZHVwbiA0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKZnJhbWVfYnVyeSAxCnR4bmEgQXBwbGljYXRpb25BcmdzIDIKaW50Y18wIC8vIDAKZ2V0Ynl0ZQpmcmFtZV9idXJ5IDIKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwppbnRjXzAgLy8gMApnZXRieXRlCmZyYW1lX2J1cnkgMwp0eG4gR3JvdXBJbmRleApwdXNoaW50IDMgLy8gMwotCmZyYW1lX2J1cnkgNApmcmFtZV9kaWcgNApndHhucyBUeXBlRW51bQppbnRjXzEgLy8gcGF5Cj09CmFzc2VydAp0eG4gR3JvdXBJbmRleApwdXNoaW50IDIgLy8gMgotCmZyYW1lX2J1cnkgNQpmcmFtZV9kaWcgNQpndHhucyBUeXBlRW51bQppbnRjXzEgLy8gcGF5Cj09CmFzc2VydAp0eG4gR3JvdXBJbmRleAppbnRjXzEgLy8gMQotCmZyYW1lX2J1cnkgNgpmcmFtZV9kaWcgMQpmcmFtZV9kaWcgMgpmcmFtZV9kaWcgMwpmcmFtZV9kaWcgNApmcmFtZV9kaWcgNQpmcmFtZV9kaWcgNgpjYWxsc3ViIGNyZWF0ZXN1YnNjcmlwdGlvbl8yNwpmcmFtZV9idXJ5IDAKYnl0ZWMgNCAvLyAweDE1MWY3Yzc1CmZyYW1lX2RpZyAwCml0b2IKY29uY2F0CmxvZwpyZXRzdWIKCi8vIGlzX3N1YnNjcmliZXJfY2FzdGVyCmlzc3Vic2NyaWJlcmNhc3Rlcl80NjoKcHJvdG8gMCAwCmludGNfMCAvLyAwCmJ5dGVjXzAgLy8gIiIKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQpmcmFtZV9idXJ5IDEKZnJhbWVfZGlnIDEKY2FsbHN1YiBpc3N1YnNjcmliZXJfMjgKZnJhbWVfYnVyeSAwCmJ5dGVjIDQgLy8gMHgxNTFmN2M3NQpmcmFtZV9kaWcgMAppdG9iCmNvbmNhdApsb2cKcmV0c3ViCgovLyBjbGFpbV9zdWJzY3JpcHRpb25fY2FzdGVyCmNsYWltc3Vic2NyaXB0aW9uY2FzdGVyXzQ3Ogpwcm90byAwIDAKaW50Y18wIC8vIDAKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQppbnRjXzAgLy8gMApnZXRieXRlCmZyYW1lX2J1cnkgMApmcmFtZV9kaWcgMApjYWxsc3ViIGNsYWltc3Vic2NyaXB0aW9uXzI5CnJldHN1YgoKLy8gdHJhbnNmZXJfc3Vic2NyaXB0aW9uX2Nhc3Rlcgp0cmFuc2ZlcnN1YnNjcmlwdGlvbmNhc3Rlcl80ODoKcHJvdG8gMCAwCmJ5dGVjXzAgLy8gIiIKaW50Y18wIC8vIDAKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQpmcmFtZV9idXJ5IDAKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgppbnRjXzAgLy8gMApnZXRieXRlCmZyYW1lX2J1cnkgMQpmcmFtZV9kaWcgMApmcmFtZV9kaWcgMQpjYWxsc3ViIHRyYW5zZmVyc3Vic2NyaXB0aW9uXzMwCnJldHN1YgoKLy8gZGVsZXRlX3N1YnNjcmlwdGlvbl9jYXN0ZXIKZGVsZXRlc3Vic2NyaXB0aW9uY2FzdGVyXzQ5Ogpwcm90byAwIDAKaW50Y18wIC8vIDAKZHVwCnR4bmEgQXBwbGljYXRpb25BcmdzIDEKaW50Y18wIC8vIDAKZ2V0Ynl0ZQpmcmFtZV9idXJ5IDEKZnJhbWVfZGlnIDEKY2FsbHN1YiBkZWxldGVzdWJzY3JpcHRpb25fMzEKZnJhbWVfYnVyeSAwCmJ5dGVjIDQgLy8gMHgxNTFmN2M3NQpmcmFtZV9kaWcgMAppdG9iCmNvbmNhdApsb2cKcmV0c3Vi","clear":"I3ByYWdtYSB2ZXJzaW9uIDEwCnB1c2hpbnQgMCAvLyAwCnJldHVybg=="},"bareActions":{"create":[],"call":["CloseOut","OptIn","UpdateApplication"]}} as unknown as Arc56Contract

/**
 * A state record containing binary data
 */
export interface BinaryState {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array | undefined
  /**
   * Gets the state value as a string
   */
  asString(): string | undefined
}

class BinaryStateValue implements BinaryState {
  constructor(private value: Uint8Array | undefined) {}

  asByteArray(): Uint8Array | undefined {
    return this.value
  }

  asString(): string | undefined {
    return this.value !== undefined ? Buffer.from(this.value).toString('utf-8') : undefined
  }
}

/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R
  ? (...args: Expand<A>) => Expand<R>
  : T extends infer O
    ? { [K in keyof O]: O[K] }
    : never


// Type definitions for ARC-56 structs

export type Discount = {
  discountType: bigint,
  discountValue: bigint,
  expiresAt: bigint,
  createdAt: bigint,
  totalClaims: bigint
}


/**
 * Converts the ABI tuple representation of a Discount to the struct representation
 */
export function DiscountFromTuple(abiTuple: [bigint, bigint, bigint, bigint, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.Discount, APP_SPEC.structs) as Discount
}

export type Subscription = {
  subscriptionId: bigint,
  productType: bigint,
  createdAt: bigint,
  expiresAt: bigint,
  duration: bigint
}


/**
 * Converts the ABI tuple representation of a Subscription to the struct representation
 */
export function SubscriptionFromTuple(abiTuple: [bigint, bigint, bigint, bigint, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.Subscription, APP_SPEC.structs) as Subscription
}

/**
 * The argument types for the TokenBasedProduct contract
 */
export type TokenBasedProductArgs = {
  /**
   * The object representation of the arguments for each method
   */
  obj: {
    'create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void': {
      /**
       * The title of the product offering subscription.
       */
      productName: string
      /**
       * The title of product's subscription, for ex Plus, Pro, etc.
       */
      subscriptionName: string
      /**
       * The address of the manager of the subscription service.
       */
      manager: string
      /**
       * The price of the subscription service.
       */
      price: bigint | number
      /**
       * The maximum number of subscriptions to be sold.
       */
      maxSubscribers: bigint | number
      /**
       * The ASA ID of the subscription service.
       */
      coinId: bigint | number
      /**
       * The ID of the Subtopia Price Oracle contract.
       */
      oracleId: bigint | number
      unitName: string
      imageUrl: string
      /**
       * The duration of the subscription service.
       */
      duration: bigint | number
    }
    'delete()void': Record<string, never>
    'get_version()string': Record<string, never>
    'get_discount()(uint64,uint64,uint64,uint64,uint64)': Record<string, never>
    'get_subscription(address)(uint64,uint64,uint64,uint64,uint64)': {
      /**
       * The subscriber address.
       */
      subscriber: string
    }
    'update_oracle_id(application)void': {
      newOracle: bigint
    }
    'update_manager(address)void': {
      /**
       * The new manager account address.
       */
      newManagerAccount: string
    }
    'update_price(uint64)void': {
      newPrice: bigint | number
    }
    'update_lifecycle(uint64)void': {
      lifecycleState: bigint | number
    }
    'is_discount_expired()uint64': Record<string, never>
    'create_discount(uint64,uint64,uint64,pay)void': {
      /**
       * The type of discount (percentage or amount).
       */
      discountType: bigint | number
      /**
       * The discount value in micro ALGOs.
       */
      discountValue: bigint | number
      /**
       * The number of seconds to append to creation date
       */
      expiresIn: bigint | number
      /**
       * The transaction fee.
       */
      feeTxn: AppMethodCallTransactionArgument
    }
    'delete_discount()void': Record<string, never>
    'compute_price(bool)uint64': {
      /**
       * Whether to apply a discount or not.
       */
      withDiscount: boolean
    }
    'create_subscription(address,application,application,pay,pay,txn)uint64': {
      /**
       * The subscriber's address.
       */
      subscriber: string
      /**
       * The locker of creator
       */
      creatorLocker: bigint
      /**
       * The oracle app used.
       */
      oracleId: bigint
      /**
       * The transaction fee paid to the app.
       */
      feeTxn?: AppMethodCallTransactionArgument
      /**
       * The platform fee paid.
       */
      platformFeeTxn?: AppMethodCallTransactionArgument
      /**
       * The payment transaction to fund the subscription.
       */
      payTxn: AppMethodCallTransactionArgument
    }
    'is_subscriber(address)uint64': {
      /**
       * The subscriber address.
       */
      subscriber: string
    }
    'claim_subscription(asset)void': {
      /**
       * The subscription asset.
       */
      subscription: bigint
    }
    'transfer_subscription(address,asset)void': {
      /**
       * The new address to transfer the subscription to.
       */
      newSubscriber: string
      /**
       * The subscription asset.
       */
      subscription: bigint
    }
    'delete_subscription(asset)uint64': {
      /**
       * The subscription ASA ID.
       */
      subscription: bigint
    }
  }
  /**
   * The tuple representation of the arguments for each method
   */
  tuple: {
    'create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void': [productName: string, subscriptionName: string, manager: string, price: bigint | number, maxSubscribers: bigint | number, coinId: bigint | number, oracleId: bigint | number, unitName: string, imageUrl: string, duration: bigint | number]
    'delete()void': []
    'get_version()string': []
    'get_discount()(uint64,uint64,uint64,uint64,uint64)': []
    'get_subscription(address)(uint64,uint64,uint64,uint64,uint64)': [subscriber: string]
    'update_oracle_id(application)void': [newOracle: bigint]
    'update_manager(address)void': [newManagerAccount: string]
    'update_price(uint64)void': [newPrice: bigint | number]
    'update_lifecycle(uint64)void': [lifecycleState: bigint | number]
    'is_discount_expired()uint64': []
    'create_discount(uint64,uint64,uint64,pay)void': [discountType: bigint | number, discountValue: bigint | number, expiresIn: bigint | number, feeTxn: AppMethodCallTransactionArgument]
    'delete_discount()void': []
    'compute_price(bool)uint64': [withDiscount: boolean]
    'create_subscription(address,application,application,pay,pay,txn)uint64': [subscriber: string, creatorLocker: bigint, oracleId: bigint, feeTxn: AppMethodCallTransactionArgument | undefined, platformFeeTxn: AppMethodCallTransactionArgument | undefined, payTxn: AppMethodCallTransactionArgument]
    'is_subscriber(address)uint64': [subscriber: string]
    'claim_subscription(asset)void': [subscription: bigint]
    'transfer_subscription(address,asset)void': [newSubscriber: string, subscription: bigint]
    'delete_subscription(asset)uint64': [subscription: bigint]
  }
}

/**
 * The return type for each method
 */
export type TokenBasedProductReturns = {
  'create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void': void
  'delete()void': void
  'get_version()string': string
  'get_discount()(uint64,uint64,uint64,uint64,uint64)': Discount
  'get_subscription(address)(uint64,uint64,uint64,uint64,uint64)': Subscription
  'update_oracle_id(application)void': void
  'update_manager(address)void': void
  'update_price(uint64)void': void
  'update_lifecycle(uint64)void': void
  'is_discount_expired()uint64': bigint
  'create_discount(uint64,uint64,uint64,pay)void': void
  'delete_discount()void': void
  'compute_price(bool)uint64': bigint
  'create_subscription(address,application,application,pay,pay,txn)uint64': bigint
  'is_subscriber(address)uint64': bigint
  'claim_subscription(asset)void': void
  'transfer_subscription(address,asset)void': void
  'delete_subscription(asset)uint64': bigint
}

/**
 * Defines the types of available calls and state of the TokenBasedProduct smart contract.
 */
export type TokenBasedProductTypes = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void' | 'create', {
      argsObj: TokenBasedProductArgs['obj']['create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void']
      argsTuple: TokenBasedProductArgs['tuple']['create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void']
      returns: TokenBasedProductReturns['create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void']
    }>
    & Record<'delete()void' | 'delete', {
      argsObj: TokenBasedProductArgs['obj']['delete()void']
      argsTuple: TokenBasedProductArgs['tuple']['delete()void']
      returns: TokenBasedProductReturns['delete()void']
    }>
    & Record<'get_version()string' | 'get_version', {
      argsObj: TokenBasedProductArgs['obj']['get_version()string']
      argsTuple: TokenBasedProductArgs['tuple']['get_version()string']
      returns: TokenBasedProductReturns['get_version()string']
    }>
    & Record<'get_discount()(uint64,uint64,uint64,uint64,uint64)' | 'get_discount', {
      argsObj: TokenBasedProductArgs['obj']['get_discount()(uint64,uint64,uint64,uint64,uint64)']
      argsTuple: TokenBasedProductArgs['tuple']['get_discount()(uint64,uint64,uint64,uint64,uint64)']
      /**
       * An expression that returns the discount.
       */
      returns: TokenBasedProductReturns['get_discount()(uint64,uint64,uint64,uint64,uint64)']
    }>
    & Record<'get_subscription(address)(uint64,uint64,uint64,uint64,uint64)' | 'get_subscription', {
      argsObj: TokenBasedProductArgs['obj']['get_subscription(address)(uint64,uint64,uint64,uint64,uint64)']
      argsTuple: TokenBasedProductArgs['tuple']['get_subscription(address)(uint64,uint64,uint64,uint64,uint64)']
      /**
       * An expression that retrieves the subscription details.
       */
      returns: TokenBasedProductReturns['get_subscription(address)(uint64,uint64,uint64,uint64,uint64)']
    }>
    & Record<'update_oracle_id(application)void' | 'update_oracle_id', {
      argsObj: TokenBasedProductArgs['obj']['update_oracle_id(application)void']
      argsTuple: TokenBasedProductArgs['tuple']['update_oracle_id(application)void']
      returns: TokenBasedProductReturns['update_oracle_id(application)void']
    }>
    & Record<'update_manager(address)void' | 'update_manager', {
      argsObj: TokenBasedProductArgs['obj']['update_manager(address)void']
      argsTuple: TokenBasedProductArgs['tuple']['update_manager(address)void']
      returns: TokenBasedProductReturns['update_manager(address)void']
    }>
    & Record<'update_price(uint64)void' | 'update_price', {
      argsObj: TokenBasedProductArgs['obj']['update_price(uint64)void']
      argsTuple: TokenBasedProductArgs['tuple']['update_price(uint64)void']
      returns: TokenBasedProductReturns['update_price(uint64)void']
    }>
    & Record<'update_lifecycle(uint64)void' | 'update_lifecycle', {
      argsObj: TokenBasedProductArgs['obj']['update_lifecycle(uint64)void']
      argsTuple: TokenBasedProductArgs['tuple']['update_lifecycle(uint64)void']
      returns: TokenBasedProductReturns['update_lifecycle(uint64)void']
    }>
    & Record<'is_discount_expired()uint64' | 'is_discount_expired', {
      argsObj: TokenBasedProductArgs['obj']['is_discount_expired()uint64']
      argsTuple: TokenBasedProductArgs['tuple']['is_discount_expired()uint64']
      /**
       * An expression that checks if the discount is expired.
       */
      returns: TokenBasedProductReturns['is_discount_expired()uint64']
    }>
    & Record<'create_discount(uint64,uint64,uint64,pay)void' | 'create_discount', {
      argsObj: TokenBasedProductArgs['obj']['create_discount(uint64,uint64,uint64,pay)void']
      argsTuple: TokenBasedProductArgs['tuple']['create_discount(uint64,uint64,uint64,pay)void']
      returns: TokenBasedProductReturns['create_discount(uint64,uint64,uint64,pay)void']
    }>
    & Record<'delete_discount()void' | 'delete_discount', {
      argsObj: TokenBasedProductArgs['obj']['delete_discount()void']
      argsTuple: TokenBasedProductArgs['tuple']['delete_discount()void']
      returns: TokenBasedProductReturns['delete_discount()void']
    }>
    & Record<'compute_price(bool)uint64' | 'compute_price', {
      argsObj: TokenBasedProductArgs['obj']['compute_price(bool)uint64']
      argsTuple: TokenBasedProductArgs['tuple']['compute_price(bool)uint64']
      /**
       * An expression that computes the price of the subscription.
       */
      returns: TokenBasedProductReturns['compute_price(bool)uint64']
    }>
    & Record<'create_subscription(address,application,application,pay,pay,txn)uint64' | 'create_subscription', {
      argsObj: TokenBasedProductArgs['obj']['create_subscription(address,application,application,pay,pay,txn)uint64']
      argsTuple: TokenBasedProductArgs['tuple']['create_subscription(address,application,application,pay,pay,txn)uint64']
      /**
       * An expression that subscribes the user and creates a new subscription.
       */
      returns: TokenBasedProductReturns['create_subscription(address,application,application,pay,pay,txn)uint64']
    }>
    & Record<'is_subscriber(address)uint64' | 'is_subscriber', {
      argsObj: TokenBasedProductArgs['obj']['is_subscriber(address)uint64']
      argsTuple: TokenBasedProductArgs['tuple']['is_subscriber(address)uint64']
      /**
       * An expression that checks if the address is a subscriber.
       */
      returns: TokenBasedProductReturns['is_subscriber(address)uint64']
    }>
    & Record<'claim_subscription(asset)void' | 'claim_subscription', {
      argsObj: TokenBasedProductArgs['obj']['claim_subscription(asset)void']
      argsTuple: TokenBasedProductArgs['tuple']['claim_subscription(asset)void']
      returns: TokenBasedProductReturns['claim_subscription(asset)void']
    }>
    & Record<'transfer_subscription(address,asset)void' | 'transfer_subscription', {
      argsObj: TokenBasedProductArgs['obj']['transfer_subscription(address,asset)void']
      argsTuple: TokenBasedProductArgs['tuple']['transfer_subscription(address,asset)void']
      returns: TokenBasedProductReturns['transfer_subscription(address,asset)void']
    }>
    & Record<'delete_subscription(asset)uint64' | 'delete_subscription', {
      argsObj: TokenBasedProductArgs['obj']['delete_subscription(asset)uint64']
      argsTuple: TokenBasedProductArgs['tuple']['delete_subscription(asset)uint64']
      /**
       * An expression that unsubscribes the user and deletes the subscription.
       */
      returns: TokenBasedProductReturns['delete_subscription(asset)uint64']
    }>
  /**
   * Defines the shape of the state of the application.
   */
  state: {
    global: {
      keys: {
        /**
         * ASA ID of the subscription, default is ALGO
         */
        coinId: bigint
        /**
         * Timestamp of the subscription service creation
         */
        createdAt: bigint
        /**
         * Duration of the subscription in seconds
         */
        duration: bigint
        /**
         * Reserved extra slot
         */
        extraSlot_1: BinaryState
        /**
         * Reserved extra slot
         */
        extraSlot_2: BinaryState
        /**
         * Image URL of the subscription NFT
         */
        imageUrl: BinaryState
        /**
         * Lifecycle state of the subscription service
         */
        lifecycle: bigint
        /**
         * Address of the manager of the subscription
         */
        manager: BinaryState
        /**
         * Max subscriptions to be sold
         */
        maxSubscribers: bigint
        /**
         * ID of Subtopia Admin Oracle contract
         */
        oracleId: bigint
        /**
         * Price of the subscription
         */
        price: bigint
        /**
         * Name of the product providing subscription
         */
        productName: BinaryState
        /**
         * Type of the subscription
         */
        productType: bigint
        /**
         * Name of the service providing subscription
         */
        subscriptionName: BinaryState
        /**
         * Total subscriptions sold
         */
        totalSubscribers: bigint
        /**
         * Unit name of the subscription NFT
         */
        unitName: BinaryState
      }
      maps: {}
    }
  }
}

/**
 * Defines the possible abi call signatures.
 */
export type TokenBasedProductSignatures = keyof TokenBasedProductTypes['methods']
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type TokenBasedProductNonVoidMethodSignatures = keyof TokenBasedProductTypes['methods'] extends infer T ? T extends keyof TokenBasedProductTypes['methods'] ? MethodReturn<T> extends void ? never : T  : never : never
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<
  Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> &
    {
      /** The args for the ABI method call, either as an ordered array or an object */
      args: Expand<TArgs>
    }
>
/**
 * Maps a method signature from the TokenBasedProduct smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends TokenBasedProductSignatures> = TokenBasedProductTypes['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the TokenBasedProduct smart contract to the method's return type
 */
export type MethodReturn<TSignature extends TokenBasedProductSignatures> = TokenBasedProductTypes['methods'][TSignature]['returns']

/**
 * Defines the shape of the keyed global state of the application.
 */
export type GlobalKeysState = TokenBasedProductTypes['state']['global']['keys']


/**
 * Defines supported create method params for this smart contract
 */
export type TokenBasedProductCreateCallParams =
  | Expand<CallParams<TokenBasedProductArgs['obj']['create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void'] | TokenBasedProductArgs['tuple']['create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void']> & {method: 'create'} & {onComplete?: OnApplicationComplete.NoOpOC} & CreateSchema>
  | Expand<CallParams<TokenBasedProductArgs['obj']['create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void'] | TokenBasedProductArgs['tuple']['create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void']> & {method: 'create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void'} & {onComplete?: OnApplicationComplete.NoOpOC} & CreateSchema>
/**
 * Defines supported update method params for this smart contract
 */
export type TokenBasedProductUpdateCallParams =
  | Expand<AppClientBareCallParams> & {method?: never}
/**
 * Defines supported delete method params for this smart contract
 */
export type TokenBasedProductDeleteCallParams =
  | Expand<CallParams<TokenBasedProductArgs['obj']['delete()void'] | TokenBasedProductArgs['tuple']['delete()void']> & {method: 'delete'}>
  | Expand<CallParams<TokenBasedProductArgs['obj']['delete()void'] | TokenBasedProductArgs['tuple']['delete()void']> & {method: 'delete()void'}>
/**
 * Defines arguments required for the deploy method.
 */
export type TokenBasedProductDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
  /**
   * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  createParams?: TokenBasedProductCreateCallParams
  /**
   * Update transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  updateParams?: TokenBasedProductUpdateCallParams
  /**
   * Delete transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  deleteParams?: TokenBasedProductDeleteCallParams
}>


/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the TokenBasedProduct smart contract
 */
export abstract class TokenBasedProductParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod<TParams extends TokenBasedProductCreateCallParams & {method: string}>(params: TParams) {
        switch(params.method) {
          case 'create':
          case 'create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void':
            return TokenBasedProductParamsFactory.create.create(params)
        }
        throw new Error(`Unknown ' + verb + ' method`)
      },

      /**
       * Constructs create ABI call params for the TokenBasedProduct smart contract using the create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(params: CallParams<TokenBasedProductArgs['obj']['create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void'] | TokenBasedProductArgs['tuple']['create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void']> & AppClientCompilationParams & {onComplete?: OnApplicationComplete.NoOpOC}): AppClientMethodCallParams & AppClientCompilationParams & {onComplete?: OnApplicationComplete.NoOpOC} {
        return {
          ...params,
          method: 'create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void' as const,
          args: Array.isArray(params.args) ? params.args : [params.args.productName, params.args.subscriptionName, params.args.manager, params.args.price, params.args.maxSubscribers, params.args.coinId, params.args.oracleId, params.args.unitName, params.args.imageUrl, params.args.duration],
        }
      },
    }
  }

  /**
   * Gets available delete ABI call param factories
   */
  static get delete() {
    return {
      _resolveByMethod<TParams extends TokenBasedProductDeleteCallParams & {method: string}>(params: TParams) {
        switch(params.method) {
          case 'delete':
          case 'delete()void':
            return TokenBasedProductParamsFactory.delete.delete(params)
        }
        throw new Error(`Unknown ' + verb + ' method`)
      },

      /**
       * Constructs delete ABI call params for the TokenBasedProduct smart contract using the delete()void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      delete(params: CallParams<TokenBasedProductArgs['obj']['delete()void'] | TokenBasedProductArgs['tuple']['delete()void']>): AppClientMethodCallParams {
        return {
          ...params,
          method: 'delete()void' as const,
          args: Array.isArray(params.args) ? params.args : [],
        }
      },
    }
  }

  /**
   * Constructs a no op call for the get_version()string ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getVersion(params: CallParams<TokenBasedProductArgs['obj']['get_version()string'] | TokenBasedProductArgs['tuple']['get_version()string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'get_version()string' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the get_discount()(uint64,uint64,uint64,uint64,uint64) ABI method
   *
   * Returns the discount if exists.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getDiscount(params: CallParams<TokenBasedProductArgs['obj']['get_discount()(uint64,uint64,uint64,uint64,uint64)'] | TokenBasedProductArgs['tuple']['get_discount()(uint64,uint64,uint64,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'get_discount()(uint64,uint64,uint64,uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the get_subscription(address)(uint64,uint64,uint64,uint64,uint64) ABI method
   *
   * Retrieves the subscription details of a given subscriber.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getSubscription(params: CallParams<TokenBasedProductArgs['obj']['get_subscription(address)(uint64,uint64,uint64,uint64,uint64)'] | TokenBasedProductArgs['tuple']['get_subscription(address)(uint64,uint64,uint64,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'get_subscription(address)(uint64,uint64,uint64,uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.subscriber],
    }
  }
  /**
   * Constructs a no op call for the update_oracle_id(application)void ABI method
   *
  * Updates the ORACLE (Subtopia Price Oracle) application ID.
  Ars: new_oracle (abi.Application): The new ORACLE application ID.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateOracleId(params: CallParams<TokenBasedProductArgs['obj']['update_oracle_id(application)void'] | TokenBasedProductArgs['tuple']['update_oracle_id(application)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'update_oracle_id(application)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.newOracle],
    }
  }
  /**
   * Constructs a no op call for the update_manager(address)void ABI method
   *
   * Updates the manager account of the subscription service.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateManager(params: CallParams<TokenBasedProductArgs['obj']['update_manager(address)void'] | TokenBasedProductArgs['tuple']['update_manager(address)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'update_manager(address)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.newManagerAccount],
    }
  }
  /**
   * Constructs a no op call for the update_price(uint64)void ABI method
   *
   * Updates the price of the subscription service.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updatePrice(params: CallParams<TokenBasedProductArgs['obj']['update_price(uint64)void'] | TokenBasedProductArgs['tuple']['update_price(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'update_price(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.newPrice],
    }
  }
  /**
   * Constructs a no op call for the update_lifecycle(uint64)void ABI method
   *
   * Set product lifecycle state (ENABLED/DISABLED). Only callable by the manager.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateLifecycle(params: CallParams<TokenBasedProductArgs['obj']['update_lifecycle(uint64)void'] | TokenBasedProductArgs['tuple']['update_lifecycle(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'update_lifecycle(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.lifecycleState],
    }
  }
  /**
   * Constructs a no op call for the is_discount_expired()uint64 ABI method
   *
   * Checks if the discount for the specified duration is expired.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static isDiscountExpired(params: CallParams<TokenBasedProductArgs['obj']['is_discount_expired()uint64'] | TokenBasedProductArgs['tuple']['is_discount_expired()uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'is_discount_expired()uint64' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the create_discount(uint64,uint64,uint64,pay)void ABI method
   *
   * Creates a new discount for the subscription service.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static createDiscount(params: CallParams<TokenBasedProductArgs['obj']['create_discount(uint64,uint64,uint64,pay)void'] | TokenBasedProductArgs['tuple']['create_discount(uint64,uint64,uint64,pay)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'create_discount(uint64,uint64,uint64,pay)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.discountType, params.args.discountValue, params.args.expiresIn, params.args.feeTxn],
    }
  }
  /**
   * Constructs a no op call for the delete_discount()void ABI method
   *
   * Deletes a discount for the subscription service.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static deleteDiscount(params: CallParams<TokenBasedProductArgs['obj']['delete_discount()void'] | TokenBasedProductArgs['tuple']['delete_discount()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'delete_discount()void' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the compute_price(bool)uint64 ABI method
   *
   * Computes the price of the subscription for the given duration.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static computePrice(params: CallParams<TokenBasedProductArgs['obj']['compute_price(bool)uint64'] | TokenBasedProductArgs['tuple']['compute_price(bool)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'compute_price(bool)uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.withDiscount],
    }
  }
  /**
   * Constructs a no op call for the create_subscription(address,application,application,pay,pay,txn)uint64 ABI method
   *
  * Subscribes a user to the subscription service and creates a new
  subscription.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static createSubscription(params: CallParams<TokenBasedProductArgs['obj']['create_subscription(address,application,application,pay,pay,txn)uint64'] | TokenBasedProductArgs['tuple']['create_subscription(address,application,application,pay,pay,txn)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'create_subscription(address,application,application,pay,pay,txn)uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.subscriber, params.args.creatorLocker, params.args.oracleId, params.args.feeTxn, params.args.platformFeeTxn, params.args.payTxn],
    }
  }
  /**
   * Constructs a no op call for the is_subscriber(address)uint64 ABI method
   *
   * Checks if a given address is a subscriber of the subscription service.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static isSubscriber(params: CallParams<TokenBasedProductArgs['obj']['is_subscriber(address)uint64'] | TokenBasedProductArgs['tuple']['is_subscriber(address)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'is_subscriber(address)uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.subscriber],
    }
  }
  /**
   * Constructs a no op call for the claim_subscription(asset)void ABI method
   *
   * Allows a subscriber to claim their subscription.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static claimSubscription(params: CallParams<TokenBasedProductArgs['obj']['claim_subscription(asset)void'] | TokenBasedProductArgs['tuple']['claim_subscription(asset)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'claim_subscription(asset)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.subscription],
    }
  }
  /**
   * Constructs a no op call for the transfer_subscription(address,asset)void ABI method
   *
   * Transfers a subscription from the sender's address to a new address.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static transferSubscription(params: CallParams<TokenBasedProductArgs['obj']['transfer_subscription(address,asset)void'] | TokenBasedProductArgs['tuple']['transfer_subscription(address,asset)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'transfer_subscription(address,asset)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.newSubscriber, params.args.subscription],
    }
  }
  /**
   * Constructs a no op call for the delete_subscription(asset)uint64 ABI method
   *
  * Unsubscribes a user from the subscription service and deletes the
  subscription.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static deleteSubscription(params: CallParams<TokenBasedProductArgs['obj']['delete_subscription(asset)uint64'] | TokenBasedProductArgs['tuple']['delete_subscription(asset)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'delete_subscription(asset)uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.subscription],
    }
  }
}

/**
 * A factory to create and deploy one or more instance of the TokenBasedProduct smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export class TokenBasedProductFactory {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  public readonly appFactory: _AppFactory

  /**
   * Creates a new instance of `TokenBasedProductFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params: Omit<AppFactoryParams, 'appSpec'>) {
    this.appFactory = new _AppFactory({
      ...params,
      appSpec: APP_SPEC,
    })
  }

  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  public get appName() {
    return this.appFactory.appName
  }

  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC
  }

  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  public get algorand(): AlgorandClient {
    return this.appFactory.algorand
  }

  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public getAppClientById(params: AppFactoryAppClientParams) {
    return new TokenBasedProductClient(this.appFactory.getAppClientById(params))
  }

  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public async getAppClientByCreatorAndName(
    params: AppFactoryResolveAppClientByCreatorAndNameParams,
  ) {
    return new TokenBasedProductClient(await this.appFactory.getAppClientByCreatorAndName(params))
  }

  /**
   * Idempotently deploys the TokenBasedProduct smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public async deploy(params: TokenBasedProductDeployParams = {}) {
    const result = await this.appFactory.deploy({
      ...params,
      createParams: params.createParams?.method ? TokenBasedProductParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams as (TokenBasedProductCreateCallParams & { args: Uint8Array[] }) : undefined,
      deleteParams: params.deleteParams?.method ? TokenBasedProductParamsFactory.delete._resolveByMethod(params.deleteParams) : params.deleteParams ? params.deleteParams as (TokenBasedProductDeleteCallParams & { args: Uint8Array[] }) : undefined,
    })
    return { result: result.result, appClient: new TokenBasedProductClient(result.appClient) }
  }

  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the TokenBasedProduct smart contract using the create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void ABI method.
       *
       * Creates a new instance of the subscription service with the provided parameters.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (params: CallParams<TokenBasedProductArgs['obj']['create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void'] | TokenBasedProductArgs['tuple']['create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void']> & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}) => {
        return this.appFactory.params.create(TokenBasedProductParamsFactory.create.create(params))
      },
    },

    /**
     * Gets available deployUpdate methods
     */
    deployUpdate: {
      /**
       * Updates an existing instance of the TokenBasedProduct smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The params for a deployUpdate call
       */
      bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams>) => {
        return this.appFactory.params.bare.deployUpdate(params)
      },
    },

    /**
     * Gets available deployDelete methods
     */
    deployDelete: {
      /**
       * Deletes an existing instance of the TokenBasedProduct smart contract using the delete()void ABI method.
       *
      * Deletes the subscription service. Can only be called by the manager account
      when there are no active subscriptions or the lifecycle state is not active.

       *
       * @param params The params for the smart contract call
       * @returns The deployDelete params
       */
      delete: (params: CallParams<TokenBasedProductArgs['obj']['delete()void'] | TokenBasedProductArgs['tuple']['delete()void']> = {args: []}) => {
        return this.appFactory.params.deployDelete(TokenBasedProductParamsFactory.delete.delete(params))
      },
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the TokenBasedProduct smart contract using the create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void ABI method.
       *
       * Creates a new instance of the subscription service with the provided parameters.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (params: CallParams<TokenBasedProductArgs['obj']['create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void'] | TokenBasedProductArgs['tuple']['create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void']> & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}) => {
        return this.appFactory.createTransaction.create(TokenBasedProductParamsFactory.create.create(params))
      },
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the TokenBasedProduct smart contract using an ABI method call using the create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void ABI method.
       *
       * Creates a new instance of the subscription service with the provided parameters.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (params: CallParams<TokenBasedProductArgs['obj']['create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void'] | TokenBasedProductArgs['tuple']['create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void']> & AppClientCompilationParams & CreateSchema & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
        const result = await this.appFactory.send.create(TokenBasedProductParamsFactory.create.create(params))
        return { result: { ...result.result, return: result.result.return as unknown as (undefined | TokenBasedProductReturns['create(string,string,address,uint64,uint64,uint64,uint64,string,string,uint64)void']) }, appClient: new TokenBasedProductClient(result.appClient) }
      },
    },

  }

}
/**
 * A client to make calls to the TokenBasedProduct smart contract
 */
export class TokenBasedProductClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  public readonly appClient: _AppClient

  /**
   * Creates a new instance of `TokenBasedProductClient`
   *
   * @param appClient An `AppClient` instance which has been created with the TokenBasedProduct app spec
   */
  constructor(appClient: _AppClient)
  /**
   * Creates a new instance of `TokenBasedProductClient`
   *
   * @param params The parameters to initialise the app client with
   */
  constructor(params: Omit<AppClientParams, 'appSpec'>)
  constructor(appClientOrParams: _AppClient | Omit<AppClientParams, 'appSpec'>) {
    this.appClient = appClientOrParams instanceof _AppClient ? appClientOrParams : new _AppClient({
      ...appClientOrParams,
      appSpec: APP_SPEC,
    })
  }

  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue<TSignature extends TokenBasedProductNonVoidMethodSignatures>(method: TSignature, returnValue: ABIReturn | undefined) {
    return returnValue !== undefined ? getArc56ReturnValue<MethodReturn<TSignature>>(returnValue, this.appClient.getABIMethod(method), APP_SPEC.structs) : undefined
  }

  /**
   * Returns a new `TokenBasedProductClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  public static async fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<TokenBasedProductClient> {
    return new TokenBasedProductClient(await _AppClient.fromCreatorAndName({...params, appSpec: APP_SPEC}))
  }

  /**
   * Returns an `TokenBasedProductClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(
    params: Omit<ResolveAppClientByNetwork, 'appSpec'>
  ): Promise<TokenBasedProductClient> {
    return new TokenBasedProductClient(await _AppClient.fromNetwork({...params, appSpec: APP_SPEC}))
  }

  /** The ID of the app instance this client is linked to. */
  public get appId() {
    return this.appClient.appId
  }

  /** The app address of the app instance this client is linked to. */
  public get appAddress() {
    return this.appClient.appAddress
  }

  /** The name of the app. */
  public get appName() {
    return this.appClient.appName
  }

  /** The ARC-56 app spec being used */
  public get appSpec() {
    return this.appClient.appSpec
  }

  /** A reference to the underlying `AlgorandClient` this app client is using. */
  public get algorand(): AlgorandClient {
    return this.appClient.algorand
  }

  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the TokenBasedProduct smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The update result
       */
      bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams>) => {
        return this.appClient.params.bare.update(params)
      },
    },

    /**
     * Gets available delete methods
     */
    delete: {
      /**
       * Deletes an existing instance of the TokenBasedProduct smart contract using the `delete()void` ABI method.
       *
      * Deletes the subscription service. Can only be called by the manager account
      when there are no active subscriptions or the lifecycle state is not active.

       *
       * @param params The params for the smart contract call
       * @returns The delete params
       */
      delete: (params: CallParams<TokenBasedProductArgs['obj']['delete()void'] | TokenBasedProductArgs['tuple']['delete()void']> = {args: []}) => {
        return this.appClient.params.delete(TokenBasedProductParamsFactory.delete.delete(params))
      },

    },

    /**
     * Gets available optIn methods
     */
    optIn: {
      /**
       * Opts the user into an existing instance of the TokenBasedProduct smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The optIn result
       */
      bare: (params?: Expand<AppClientBareCallParams>) => {
        return this.appClient.params.bare.optIn(params)
      },
    },

    /**
     * Gets available closeOut methods
     */
    closeOut: {
      /**
       * Makes a close out call to an existing instance of the TokenBasedProduct smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The closeOut result
       */
      bare: (params?: Expand<AppClientBareCallParams>) => {
        return this.appClient.params.bare.closeOut(params)
      },
    },

    /**
     * Makes a clear_state call to an existing instance of the TokenBasedProduct smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.params.bare.clearState(params)
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `get_version()string` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getVersion: (params: CallParams<TokenBasedProductArgs['obj']['get_version()string'] | TokenBasedProductArgs['tuple']['get_version()string']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(TokenBasedProductParamsFactory.getVersion(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `get_discount()(uint64,uint64,uint64,uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the discount if exists.
     *
     * @param params The params for the smart contract call
     * @returns The call params: An expression that returns the discount.
     */
    getDiscount: (params: CallParams<TokenBasedProductArgs['obj']['get_discount()(uint64,uint64,uint64,uint64,uint64)'] | TokenBasedProductArgs['tuple']['get_discount()(uint64,uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(TokenBasedProductParamsFactory.getDiscount(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `get_subscription(address)(uint64,uint64,uint64,uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Retrieves the subscription details of a given subscriber.
     *
     * @param params The params for the smart contract call
     * @returns The call params: An expression that retrieves the subscription details.
     */
    getSubscription: (params: CallParams<TokenBasedProductArgs['obj']['get_subscription(address)(uint64,uint64,uint64,uint64,uint64)'] | TokenBasedProductArgs['tuple']['get_subscription(address)(uint64,uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(TokenBasedProductParamsFactory.getSubscription(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `update_oracle_id(application)void` ABI method.
     *
    * Updates the ORACLE (Subtopia Price Oracle) application ID.
    Ars: new_oracle (abi.Application): The new ORACLE application ID.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateOracleId: (params: CallParams<TokenBasedProductArgs['obj']['update_oracle_id(application)void'] | TokenBasedProductArgs['tuple']['update_oracle_id(application)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(TokenBasedProductParamsFactory.updateOracleId(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `update_manager(address)void` ABI method.
     *
     * Updates the manager account of the subscription service.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateManager: (params: CallParams<TokenBasedProductArgs['obj']['update_manager(address)void'] | TokenBasedProductArgs['tuple']['update_manager(address)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(TokenBasedProductParamsFactory.updateManager(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `update_price(uint64)void` ABI method.
     *
     * Updates the price of the subscription service.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updatePrice: (params: CallParams<TokenBasedProductArgs['obj']['update_price(uint64)void'] | TokenBasedProductArgs['tuple']['update_price(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(TokenBasedProductParamsFactory.updatePrice(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `update_lifecycle(uint64)void` ABI method.
     *
     * Set product lifecycle state (ENABLED/DISABLED). Only callable by the manager.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateLifecycle: (params: CallParams<TokenBasedProductArgs['obj']['update_lifecycle(uint64)void'] | TokenBasedProductArgs['tuple']['update_lifecycle(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(TokenBasedProductParamsFactory.updateLifecycle(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `is_discount_expired()uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Checks if the discount for the specified duration is expired.
     *
     * @param params The params for the smart contract call
     * @returns The call params: An expression that checks if the discount is expired.
     */
    isDiscountExpired: (params: CallParams<TokenBasedProductArgs['obj']['is_discount_expired()uint64'] | TokenBasedProductArgs['tuple']['is_discount_expired()uint64']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(TokenBasedProductParamsFactory.isDiscountExpired(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `create_discount(uint64,uint64,uint64,pay)void` ABI method.
     *
     * Creates a new discount for the subscription service.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    createDiscount: (params: CallParams<TokenBasedProductArgs['obj']['create_discount(uint64,uint64,uint64,pay)void'] | TokenBasedProductArgs['tuple']['create_discount(uint64,uint64,uint64,pay)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(TokenBasedProductParamsFactory.createDiscount(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `delete_discount()void` ABI method.
     *
     * Deletes a discount for the subscription service.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    deleteDiscount: (params: CallParams<TokenBasedProductArgs['obj']['delete_discount()void'] | TokenBasedProductArgs['tuple']['delete_discount()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(TokenBasedProductParamsFactory.deleteDiscount(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `compute_price(bool)uint64` ABI method.
     *
     * Computes the price of the subscription for the given duration.
     *
     * @param params The params for the smart contract call
     * @returns The call params: An expression that computes the price of the subscription.
     */
    computePrice: (params: CallParams<TokenBasedProductArgs['obj']['compute_price(bool)uint64'] | TokenBasedProductArgs['tuple']['compute_price(bool)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(TokenBasedProductParamsFactory.computePrice(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `create_subscription(address,application,application,pay,pay,txn)uint64` ABI method.
     *
    * Subscribes a user to the subscription service and creates a new
    subscription.

     *
     * @param params The params for the smart contract call
     * @returns The call params: An expression that subscribes the user and creates a new subscription.
     */
    createSubscription: (params: CallParams<TokenBasedProductArgs['obj']['create_subscription(address,application,application,pay,pay,txn)uint64'] | TokenBasedProductArgs['tuple']['create_subscription(address,application,application,pay,pay,txn)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(TokenBasedProductParamsFactory.createSubscription(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `is_subscriber(address)uint64` ABI method.
     *
     * Checks if a given address is a subscriber of the subscription service.
     *
     * @param params The params for the smart contract call
     * @returns The call params: An expression that checks if the address is a subscriber.
     */
    isSubscriber: (params: CallParams<TokenBasedProductArgs['obj']['is_subscriber(address)uint64'] | TokenBasedProductArgs['tuple']['is_subscriber(address)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(TokenBasedProductParamsFactory.isSubscriber(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `claim_subscription(asset)void` ABI method.
     *
     * Allows a subscriber to claim their subscription.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    claimSubscription: (params: CallParams<TokenBasedProductArgs['obj']['claim_subscription(asset)void'] | TokenBasedProductArgs['tuple']['claim_subscription(asset)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(TokenBasedProductParamsFactory.claimSubscription(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `transfer_subscription(address,asset)void` ABI method.
     *
     * Transfers a subscription from the sender's address to a new address.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    transferSubscription: (params: CallParams<TokenBasedProductArgs['obj']['transfer_subscription(address,asset)void'] | TokenBasedProductArgs['tuple']['transfer_subscription(address,asset)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(TokenBasedProductParamsFactory.transferSubscription(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `delete_subscription(asset)uint64` ABI method.
     *
    * Unsubscribes a user from the subscription service and deletes the
    subscription.

     *
     * @param params The params for the smart contract call
     * @returns The call params: An expression that unsubscribes the user and deletes the subscription.
     */
    deleteSubscription: (params: CallParams<TokenBasedProductArgs['obj']['delete_subscription(asset)uint64'] | TokenBasedProductArgs['tuple']['delete_subscription(asset)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(TokenBasedProductParamsFactory.deleteSubscription(params))
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the TokenBasedProduct smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The update result
       */
      bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams>) => {
        return this.appClient.createTransaction.bare.update(params)
      },
    },

    /**
     * Gets available delete methods
     */
    delete: {
      /**
       * Deletes an existing instance of the TokenBasedProduct smart contract using the `delete()void` ABI method.
       *
      * Deletes the subscription service. Can only be called by the manager account
      when there are no active subscriptions or the lifecycle state is not active.

       *
       * @param params The params for the smart contract call
       * @returns The delete transaction
       */
      delete: (params: CallParams<TokenBasedProductArgs['obj']['delete()void'] | TokenBasedProductArgs['tuple']['delete()void']> = {args: []}) => {
        return this.appClient.createTransaction.delete(TokenBasedProductParamsFactory.delete.delete(params))
      },

    },

    /**
     * Gets available optIn methods
     */
    optIn: {
      /**
       * Opts the user into an existing instance of the TokenBasedProduct smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The optIn result
       */
      bare: (params?: Expand<AppClientBareCallParams>) => {
        return this.appClient.createTransaction.bare.optIn(params)
      },
    },

    /**
     * Gets available closeOut methods
     */
    closeOut: {
      /**
       * Makes a close out call to an existing instance of the TokenBasedProduct smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The closeOut result
       */
      bare: (params?: Expand<AppClientBareCallParams>) => {
        return this.appClient.createTransaction.bare.closeOut(params)
      },
    },

    /**
     * Makes a clear_state call to an existing instance of the TokenBasedProduct smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.createTransaction.bare.clearState(params)
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `get_version()string` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getVersion: (params: CallParams<TokenBasedProductArgs['obj']['get_version()string'] | TokenBasedProductArgs['tuple']['get_version()string']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(TokenBasedProductParamsFactory.getVersion(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `get_discount()(uint64,uint64,uint64,uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the discount if exists.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: An expression that returns the discount.
     */
    getDiscount: (params: CallParams<TokenBasedProductArgs['obj']['get_discount()(uint64,uint64,uint64,uint64,uint64)'] | TokenBasedProductArgs['tuple']['get_discount()(uint64,uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(TokenBasedProductParamsFactory.getDiscount(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `get_subscription(address)(uint64,uint64,uint64,uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Retrieves the subscription details of a given subscriber.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: An expression that retrieves the subscription details.
     */
    getSubscription: (params: CallParams<TokenBasedProductArgs['obj']['get_subscription(address)(uint64,uint64,uint64,uint64,uint64)'] | TokenBasedProductArgs['tuple']['get_subscription(address)(uint64,uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(TokenBasedProductParamsFactory.getSubscription(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `update_oracle_id(application)void` ABI method.
     *
    * Updates the ORACLE (Subtopia Price Oracle) application ID.
    Ars: new_oracle (abi.Application): The new ORACLE application ID.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateOracleId: (params: CallParams<TokenBasedProductArgs['obj']['update_oracle_id(application)void'] | TokenBasedProductArgs['tuple']['update_oracle_id(application)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(TokenBasedProductParamsFactory.updateOracleId(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `update_manager(address)void` ABI method.
     *
     * Updates the manager account of the subscription service.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateManager: (params: CallParams<TokenBasedProductArgs['obj']['update_manager(address)void'] | TokenBasedProductArgs['tuple']['update_manager(address)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(TokenBasedProductParamsFactory.updateManager(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `update_price(uint64)void` ABI method.
     *
     * Updates the price of the subscription service.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updatePrice: (params: CallParams<TokenBasedProductArgs['obj']['update_price(uint64)void'] | TokenBasedProductArgs['tuple']['update_price(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(TokenBasedProductParamsFactory.updatePrice(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `update_lifecycle(uint64)void` ABI method.
     *
     * Set product lifecycle state (ENABLED/DISABLED). Only callable by the manager.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateLifecycle: (params: CallParams<TokenBasedProductArgs['obj']['update_lifecycle(uint64)void'] | TokenBasedProductArgs['tuple']['update_lifecycle(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(TokenBasedProductParamsFactory.updateLifecycle(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `is_discount_expired()uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Checks if the discount for the specified duration is expired.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: An expression that checks if the discount is expired.
     */
    isDiscountExpired: (params: CallParams<TokenBasedProductArgs['obj']['is_discount_expired()uint64'] | TokenBasedProductArgs['tuple']['is_discount_expired()uint64']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(TokenBasedProductParamsFactory.isDiscountExpired(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `create_discount(uint64,uint64,uint64,pay)void` ABI method.
     *
     * Creates a new discount for the subscription service.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    createDiscount: (params: CallParams<TokenBasedProductArgs['obj']['create_discount(uint64,uint64,uint64,pay)void'] | TokenBasedProductArgs['tuple']['create_discount(uint64,uint64,uint64,pay)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(TokenBasedProductParamsFactory.createDiscount(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `delete_discount()void` ABI method.
     *
     * Deletes a discount for the subscription service.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    deleteDiscount: (params: CallParams<TokenBasedProductArgs['obj']['delete_discount()void'] | TokenBasedProductArgs['tuple']['delete_discount()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(TokenBasedProductParamsFactory.deleteDiscount(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `compute_price(bool)uint64` ABI method.
     *
     * Computes the price of the subscription for the given duration.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: An expression that computes the price of the subscription.
     */
    computePrice: (params: CallParams<TokenBasedProductArgs['obj']['compute_price(bool)uint64'] | TokenBasedProductArgs['tuple']['compute_price(bool)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(TokenBasedProductParamsFactory.computePrice(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `create_subscription(address,application,application,pay,pay,txn)uint64` ABI method.
     *
    * Subscribes a user to the subscription service and creates a new
    subscription.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction: An expression that subscribes the user and creates a new subscription.
     */
    createSubscription: (params: CallParams<TokenBasedProductArgs['obj']['create_subscription(address,application,application,pay,pay,txn)uint64'] | TokenBasedProductArgs['tuple']['create_subscription(address,application,application,pay,pay,txn)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(TokenBasedProductParamsFactory.createSubscription(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `is_subscriber(address)uint64` ABI method.
     *
     * Checks if a given address is a subscriber of the subscription service.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: An expression that checks if the address is a subscriber.
     */
    isSubscriber: (params: CallParams<TokenBasedProductArgs['obj']['is_subscriber(address)uint64'] | TokenBasedProductArgs['tuple']['is_subscriber(address)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(TokenBasedProductParamsFactory.isSubscriber(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `claim_subscription(asset)void` ABI method.
     *
     * Allows a subscriber to claim their subscription.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    claimSubscription: (params: CallParams<TokenBasedProductArgs['obj']['claim_subscription(asset)void'] | TokenBasedProductArgs['tuple']['claim_subscription(asset)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(TokenBasedProductParamsFactory.claimSubscription(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `transfer_subscription(address,asset)void` ABI method.
     *
     * Transfers a subscription from the sender's address to a new address.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    transferSubscription: (params: CallParams<TokenBasedProductArgs['obj']['transfer_subscription(address,asset)void'] | TokenBasedProductArgs['tuple']['transfer_subscription(address,asset)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(TokenBasedProductParamsFactory.transferSubscription(params))
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `delete_subscription(asset)uint64` ABI method.
     *
    * Unsubscribes a user from the subscription service and deletes the
    subscription.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction: An expression that unsubscribes the user and deletes the subscription.
     */
    deleteSubscription: (params: CallParams<TokenBasedProductArgs['obj']['delete_subscription(asset)uint64'] | TokenBasedProductArgs['tuple']['delete_subscription(asset)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(TokenBasedProductParamsFactory.deleteSubscription(params))
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the TokenBasedProduct smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The update result
       */
      bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & SendParams>) => {
        return this.appClient.send.bare.update(params)
      },
    },

    /**
     * Gets available delete methods
     */
    delete: {
      /**
       * Deletes an existing instance of the TokenBasedProduct smart contract using the `delete()void` ABI method.
       *
      * Deletes the subscription service. Can only be called by the manager account
      when there are no active subscriptions or the lifecycle state is not active.

       *
       * @param params The params for the smart contract call
       * @returns The delete result
       */
      delete: async (params: CallParams<TokenBasedProductArgs['obj']['delete()void'] | TokenBasedProductArgs['tuple']['delete()void']> & SendParams = {args: []}) => {
        const result = await this.appClient.send.delete(TokenBasedProductParamsFactory.delete.delete(params))
        return {...result, return: result.return as unknown as (undefined | TokenBasedProductReturns['delete()void'])}
      },

    },

    /**
     * Gets available optIn methods
     */
    optIn: {
      /**
       * Opts the user into an existing instance of the TokenBasedProduct smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The optIn result
       */
      bare: (params?: Expand<AppClientBareCallParams & SendParams>) => {
        return this.appClient.send.bare.optIn(params)
      },
    },

    /**
     * Gets available closeOut methods
     */
    closeOut: {
      /**
       * Makes a close out call to an existing instance of the TokenBasedProduct smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The closeOut result
       */
      bare: (params?: Expand<AppClientBareCallParams & SendParams>) => {
        return this.appClient.send.bare.closeOut(params)
      },
    },

    /**
     * Makes a clear_state call to an existing instance of the TokenBasedProduct smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => {
      return this.appClient.send.bare.clearState(params)
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `get_version()string` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getVersion: async (params: CallParams<TokenBasedProductArgs['obj']['get_version()string'] | TokenBasedProductArgs['tuple']['get_version()string']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(TokenBasedProductParamsFactory.getVersion(params))
      return {...result, return: result.return as unknown as (undefined | TokenBasedProductReturns['get_version()string'])}
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `get_discount()(uint64,uint64,uint64,uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the discount if exists.
     *
     * @param params The params for the smart contract call
     * @returns The call result: An expression that returns the discount.
     */
    getDiscount: async (params: CallParams<TokenBasedProductArgs['obj']['get_discount()(uint64,uint64,uint64,uint64,uint64)'] | TokenBasedProductArgs['tuple']['get_discount()(uint64,uint64,uint64,uint64,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(TokenBasedProductParamsFactory.getDiscount(params))
      return {...result, return: result.return as unknown as (undefined | TokenBasedProductReturns['get_discount()(uint64,uint64,uint64,uint64,uint64)'])}
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `get_subscription(address)(uint64,uint64,uint64,uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Retrieves the subscription details of a given subscriber.
     *
     * @param params The params for the smart contract call
     * @returns The call result: An expression that retrieves the subscription details.
     */
    getSubscription: async (params: CallParams<TokenBasedProductArgs['obj']['get_subscription(address)(uint64,uint64,uint64,uint64,uint64)'] | TokenBasedProductArgs['tuple']['get_subscription(address)(uint64,uint64,uint64,uint64,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(TokenBasedProductParamsFactory.getSubscription(params))
      return {...result, return: result.return as unknown as (undefined | TokenBasedProductReturns['get_subscription(address)(uint64,uint64,uint64,uint64,uint64)'])}
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `update_oracle_id(application)void` ABI method.
     *
    * Updates the ORACLE (Subtopia Price Oracle) application ID.
    Ars: new_oracle (abi.Application): The new ORACLE application ID.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateOracleId: async (params: CallParams<TokenBasedProductArgs['obj']['update_oracle_id(application)void'] | TokenBasedProductArgs['tuple']['update_oracle_id(application)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(TokenBasedProductParamsFactory.updateOracleId(params))
      return {...result, return: result.return as unknown as (undefined | TokenBasedProductReturns['update_oracle_id(application)void'])}
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `update_manager(address)void` ABI method.
     *
     * Updates the manager account of the subscription service.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateManager: async (params: CallParams<TokenBasedProductArgs['obj']['update_manager(address)void'] | TokenBasedProductArgs['tuple']['update_manager(address)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(TokenBasedProductParamsFactory.updateManager(params))
      return {...result, return: result.return as unknown as (undefined | TokenBasedProductReturns['update_manager(address)void'])}
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `update_price(uint64)void` ABI method.
     *
     * Updates the price of the subscription service.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updatePrice: async (params: CallParams<TokenBasedProductArgs['obj']['update_price(uint64)void'] | TokenBasedProductArgs['tuple']['update_price(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(TokenBasedProductParamsFactory.updatePrice(params))
      return {...result, return: result.return as unknown as (undefined | TokenBasedProductReturns['update_price(uint64)void'])}
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `update_lifecycle(uint64)void` ABI method.
     *
     * Set product lifecycle state (ENABLED/DISABLED). Only callable by the manager.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateLifecycle: async (params: CallParams<TokenBasedProductArgs['obj']['update_lifecycle(uint64)void'] | TokenBasedProductArgs['tuple']['update_lifecycle(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(TokenBasedProductParamsFactory.updateLifecycle(params))
      return {...result, return: result.return as unknown as (undefined | TokenBasedProductReturns['update_lifecycle(uint64)void'])}
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `is_discount_expired()uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Checks if the discount for the specified duration is expired.
     *
     * @param params The params for the smart contract call
     * @returns The call result: An expression that checks if the discount is expired.
     */
    isDiscountExpired: async (params: CallParams<TokenBasedProductArgs['obj']['is_discount_expired()uint64'] | TokenBasedProductArgs['tuple']['is_discount_expired()uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(TokenBasedProductParamsFactory.isDiscountExpired(params))
      return {...result, return: result.return as unknown as (undefined | TokenBasedProductReturns['is_discount_expired()uint64'])}
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `create_discount(uint64,uint64,uint64,pay)void` ABI method.
     *
     * Creates a new discount for the subscription service.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    createDiscount: async (params: CallParams<TokenBasedProductArgs['obj']['create_discount(uint64,uint64,uint64,pay)void'] | TokenBasedProductArgs['tuple']['create_discount(uint64,uint64,uint64,pay)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(TokenBasedProductParamsFactory.createDiscount(params))
      return {...result, return: result.return as unknown as (undefined | TokenBasedProductReturns['create_discount(uint64,uint64,uint64,pay)void'])}
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `delete_discount()void` ABI method.
     *
     * Deletes a discount for the subscription service.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    deleteDiscount: async (params: CallParams<TokenBasedProductArgs['obj']['delete_discount()void'] | TokenBasedProductArgs['tuple']['delete_discount()void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(TokenBasedProductParamsFactory.deleteDiscount(params))
      return {...result, return: result.return as unknown as (undefined | TokenBasedProductReturns['delete_discount()void'])}
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `compute_price(bool)uint64` ABI method.
     *
     * Computes the price of the subscription for the given duration.
     *
     * @param params The params for the smart contract call
     * @returns The call result: An expression that computes the price of the subscription.
     */
    computePrice: async (params: CallParams<TokenBasedProductArgs['obj']['compute_price(bool)uint64'] | TokenBasedProductArgs['tuple']['compute_price(bool)uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(TokenBasedProductParamsFactory.computePrice(params))
      return {...result, return: result.return as unknown as (undefined | TokenBasedProductReturns['compute_price(bool)uint64'])}
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `create_subscription(address,application,application,pay,pay,txn)uint64` ABI method.
     *
    * Subscribes a user to the subscription service and creates a new
    subscription.

     *
     * @param params The params for the smart contract call
     * @returns The call result: An expression that subscribes the user and creates a new subscription.
     */
    createSubscription: async (params: CallParams<TokenBasedProductArgs['obj']['create_subscription(address,application,application,pay,pay,txn)uint64'] | TokenBasedProductArgs['tuple']['create_subscription(address,application,application,pay,pay,txn)uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(TokenBasedProductParamsFactory.createSubscription(params))
      return {...result, return: result.return as unknown as (undefined | TokenBasedProductReturns['create_subscription(address,application,application,pay,pay,txn)uint64'])}
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `is_subscriber(address)uint64` ABI method.
     *
     * Checks if a given address is a subscriber of the subscription service.
     *
     * @param params The params for the smart contract call
     * @returns The call result: An expression that checks if the address is a subscriber.
     */
    isSubscriber: async (params: CallParams<TokenBasedProductArgs['obj']['is_subscriber(address)uint64'] | TokenBasedProductArgs['tuple']['is_subscriber(address)uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(TokenBasedProductParamsFactory.isSubscriber(params))
      return {...result, return: result.return as unknown as (undefined | TokenBasedProductReturns['is_subscriber(address)uint64'])}
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `claim_subscription(asset)void` ABI method.
     *
     * Allows a subscriber to claim their subscription.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    claimSubscription: async (params: CallParams<TokenBasedProductArgs['obj']['claim_subscription(asset)void'] | TokenBasedProductArgs['tuple']['claim_subscription(asset)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(TokenBasedProductParamsFactory.claimSubscription(params))
      return {...result, return: result.return as unknown as (undefined | TokenBasedProductReturns['claim_subscription(asset)void'])}
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `transfer_subscription(address,asset)void` ABI method.
     *
     * Transfers a subscription from the sender's address to a new address.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    transferSubscription: async (params: CallParams<TokenBasedProductArgs['obj']['transfer_subscription(address,asset)void'] | TokenBasedProductArgs['tuple']['transfer_subscription(address,asset)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(TokenBasedProductParamsFactory.transferSubscription(params))
      return {...result, return: result.return as unknown as (undefined | TokenBasedProductReturns['transfer_subscription(address,asset)void'])}
    },

    /**
     * Makes a call to the TokenBasedProduct smart contract using the `delete_subscription(asset)uint64` ABI method.
     *
    * Unsubscribes a user from the subscription service and deletes the
    subscription.

     *
     * @param params The params for the smart contract call
     * @returns The call result: An expression that unsubscribes the user and deletes the subscription.
     */
    deleteSubscription: async (params: CallParams<TokenBasedProductArgs['obj']['delete_subscription(asset)uint64'] | TokenBasedProductArgs['tuple']['delete_subscription(asset)uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(TokenBasedProductParamsFactory.deleteSubscription(params))
      return {...result, return: result.return as unknown as (undefined | TokenBasedProductReturns['delete_subscription(asset)uint64'])}
    },

  }

  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  public clone(params: CloneAppClientParams) {
    return new TokenBasedProductClient(this.appClient.clone(params))
  }

  /**
   * Makes a readonly (simulated) call to the TokenBasedProduct smart contract using the `get_version()string` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getVersion(params: CallParams<TokenBasedProductArgs['obj']['get_version()string'] | TokenBasedProductArgs['tuple']['get_version()string']> = {args: []}) {
    const result = await this.appClient.send.call(TokenBasedProductParamsFactory.getVersion(params))
    return result.return as unknown as TokenBasedProductReturns['get_version()string']
  }

  /**
   * Makes a readonly (simulated) call to the TokenBasedProduct smart contract using the `get_discount()(uint64,uint64,uint64,uint64,uint64)` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Returns the discount if exists.
   *
   * @param params The params for the smart contract call
   * @returns The call result: An expression that returns the discount.
   */
  async getDiscount(params: CallParams<TokenBasedProductArgs['obj']['get_discount()(uint64,uint64,uint64,uint64,uint64)'] | TokenBasedProductArgs['tuple']['get_discount()(uint64,uint64,uint64,uint64,uint64)']> = {args: []}) {
    const result = await this.appClient.send.call(TokenBasedProductParamsFactory.getDiscount(params))
    return result.return as unknown as TokenBasedProductReturns['get_discount()(uint64,uint64,uint64,uint64,uint64)']
  }

  /**
   * Makes a readonly (simulated) call to the TokenBasedProduct smart contract using the `get_subscription(address)(uint64,uint64,uint64,uint64,uint64)` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Retrieves the subscription details of a given subscriber.
   *
   * @param params The params for the smart contract call
   * @returns The call result: An expression that retrieves the subscription details.
   */
  async getSubscription(params: CallParams<TokenBasedProductArgs['obj']['get_subscription(address)(uint64,uint64,uint64,uint64,uint64)'] | TokenBasedProductArgs['tuple']['get_subscription(address)(uint64,uint64,uint64,uint64,uint64)']>) {
    const result = await this.appClient.send.call(TokenBasedProductParamsFactory.getSubscription(params))
    return result.return as unknown as TokenBasedProductReturns['get_subscription(address)(uint64,uint64,uint64,uint64,uint64)']
  }

  /**
   * Makes a readonly (simulated) call to the TokenBasedProduct smart contract using the `is_discount_expired()uint64` ABI method.
   *
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Checks if the discount for the specified duration is expired.
   *
   * @param params The params for the smart contract call
   * @returns The call result: An expression that checks if the discount is expired.
   */
  async isDiscountExpired(params: CallParams<TokenBasedProductArgs['obj']['is_discount_expired()uint64'] | TokenBasedProductArgs['tuple']['is_discount_expired()uint64']> = {args: []}) {
    const result = await this.appClient.send.call(TokenBasedProductParamsFactory.isDiscountExpired(params))
    return result.return as unknown as TokenBasedProductReturns['is_discount_expired()uint64']
  }

  /**
   * Methods to access state for the current TokenBasedProduct app
   */
  state = {
    /**
     * Methods to access global state for the current TokenBasedProduct app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async (): Promise<Partial<Expand<GlobalKeysState>>> => {
        const result = await this.appClient.state.global.getAll()
        return {
          coinId: result.coin_id,
          createdAt: result.created_at,
          duration: result.duration,
          extraSlot_1: new BinaryStateValue(result.extra_slot_1),
          extraSlot_2: new BinaryStateValue(result.extra_slot_2),
          imageUrl: new BinaryStateValue(result.image_url),
          lifecycle: result.lifecycle,
          manager: new BinaryStateValue(result.manager),
          maxSubscribers: result.max_subscribers,
          oracleId: result.oracle_id,
          price: result.price,
          productName: new BinaryStateValue(result.product_name),
          productType: result.product_type,
          subscriptionName: new BinaryStateValue(result.subscription_name),
          totalSubscribers: result.total_subscribers,
          unitName: new BinaryStateValue(result.unit_name),
        }
      },
      /**
       * Get the current value of the coin_id key in global state
       */
      coinId: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("coin_id")) as bigint | undefined },
      /**
       * Get the current value of the created_at key in global state
       */
      createdAt: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("created_at")) as bigint | undefined },
      /**
       * Get the current value of the duration key in global state
       */
      duration: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("duration")) as bigint | undefined },
      /**
       * Get the current value of the extra_slot_1 key in global state
       */
      extraSlot_1: async (): Promise<BinaryState> => { return new BinaryStateValue((await this.appClient.state.global.getValue("extra_slot_1")) as Uint8Array | undefined) },
      /**
       * Get the current value of the extra_slot_2 key in global state
       */
      extraSlot_2: async (): Promise<BinaryState> => { return new BinaryStateValue((await this.appClient.state.global.getValue("extra_slot_2")) as Uint8Array | undefined) },
      /**
       * Get the current value of the image_url key in global state
       */
      imageUrl: async (): Promise<BinaryState> => { return new BinaryStateValue((await this.appClient.state.global.getValue("image_url")) as Uint8Array | undefined) },
      /**
       * Get the current value of the lifecycle key in global state
       */
      lifecycle: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("lifecycle")) as bigint | undefined },
      /**
       * Get the current value of the manager key in global state
       */
      manager: async (): Promise<BinaryState> => { return new BinaryStateValue((await this.appClient.state.global.getValue("manager")) as Uint8Array | undefined) },
      /**
       * Get the current value of the max_subscribers key in global state
       */
      maxSubscribers: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("max_subscribers")) as bigint | undefined },
      /**
       * Get the current value of the oracle_id key in global state
       */
      oracleId: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("oracle_id")) as bigint | undefined },
      /**
       * Get the current value of the price key in global state
       */
      price: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("price")) as bigint | undefined },
      /**
       * Get the current value of the product_name key in global state
       */
      productName: async (): Promise<BinaryState> => { return new BinaryStateValue((await this.appClient.state.global.getValue("product_name")) as Uint8Array | undefined) },
      /**
       * Get the current value of the product_type key in global state
       */
      productType: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("product_type")) as bigint | undefined },
      /**
       * Get the current value of the subscription_name key in global state
       */
      subscriptionName: async (): Promise<BinaryState> => { return new BinaryStateValue((await this.appClient.state.global.getValue("subscription_name")) as Uint8Array | undefined) },
      /**
       * Get the current value of the total_subscribers key in global state
       */
      totalSubscribers: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("total_subscribers")) as bigint | undefined },
      /**
       * Get the current value of the unit_name key in global state
       */
      unitName: async (): Promise<BinaryState> => { return new BinaryStateValue((await this.appClient.state.global.getValue("unit_name")) as Uint8Array | undefined) },
    },
  }

  public newGroup(): TokenBasedProductComposer {
    const client = this
    const composer = this.algorand.newGroup()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: ABIReturn | undefined) => any)> = []
    return {
      /**
       * Add a get_version()string method call against the TokenBasedProduct contract
       */
      getVersion(params: CallParams<TokenBasedProductArgs['obj']['get_version()string'] | TokenBasedProductArgs['tuple']['get_version()string']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getVersion(params)))
        resultMappers.push((v) => client.decodeReturnValue('get_version()string', v))
        return this
      },
      /**
       * Add a get_discount()(uint64,uint64,uint64,uint64,uint64) method call against the TokenBasedProduct contract
       */
      getDiscount(params: CallParams<TokenBasedProductArgs['obj']['get_discount()(uint64,uint64,uint64,uint64,uint64)'] | TokenBasedProductArgs['tuple']['get_discount()(uint64,uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getDiscount(params)))
        resultMappers.push((v) => client.decodeReturnValue('get_discount()(uint64,uint64,uint64,uint64,uint64)', v))
        return this
      },
      /**
       * Add a get_subscription(address)(uint64,uint64,uint64,uint64,uint64) method call against the TokenBasedProduct contract
       */
      getSubscription(params: CallParams<TokenBasedProductArgs['obj']['get_subscription(address)(uint64,uint64,uint64,uint64,uint64)'] | TokenBasedProductArgs['tuple']['get_subscription(address)(uint64,uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getSubscription(params)))
        resultMappers.push((v) => client.decodeReturnValue('get_subscription(address)(uint64,uint64,uint64,uint64,uint64)', v))
        return this
      },
      /**
       * Add a update_oracle_id(application)void method call against the TokenBasedProduct contract
       */
      updateOracleId(params: CallParams<TokenBasedProductArgs['obj']['update_oracle_id(application)void'] | TokenBasedProductArgs['tuple']['update_oracle_id(application)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateOracleId(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a update_manager(address)void method call against the TokenBasedProduct contract
       */
      updateManager(params: CallParams<TokenBasedProductArgs['obj']['update_manager(address)void'] | TokenBasedProductArgs['tuple']['update_manager(address)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateManager(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a update_price(uint64)void method call against the TokenBasedProduct contract
       */
      updatePrice(params: CallParams<TokenBasedProductArgs['obj']['update_price(uint64)void'] | TokenBasedProductArgs['tuple']['update_price(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updatePrice(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a update_lifecycle(uint64)void method call against the TokenBasedProduct contract
       */
      updateLifecycle(params: CallParams<TokenBasedProductArgs['obj']['update_lifecycle(uint64)void'] | TokenBasedProductArgs['tuple']['update_lifecycle(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateLifecycle(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a is_discount_expired()uint64 method call against the TokenBasedProduct contract
       */
      isDiscountExpired(params: CallParams<TokenBasedProductArgs['obj']['is_discount_expired()uint64'] | TokenBasedProductArgs['tuple']['is_discount_expired()uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.isDiscountExpired(params)))
        resultMappers.push((v) => client.decodeReturnValue('is_discount_expired()uint64', v))
        return this
      },
      /**
       * Add a create_discount(uint64,uint64,uint64,pay)void method call against the TokenBasedProduct contract
       */
      createDiscount(params: CallParams<TokenBasedProductArgs['obj']['create_discount(uint64,uint64,uint64,pay)void'] | TokenBasedProductArgs['tuple']['create_discount(uint64,uint64,uint64,pay)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.createDiscount(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a delete_discount()void method call against the TokenBasedProduct contract
       */
      deleteDiscount(params: CallParams<TokenBasedProductArgs['obj']['delete_discount()void'] | TokenBasedProductArgs['tuple']['delete_discount()void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.deleteDiscount(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a compute_price(bool)uint64 method call against the TokenBasedProduct contract
       */
      computePrice(params: CallParams<TokenBasedProductArgs['obj']['compute_price(bool)uint64'] | TokenBasedProductArgs['tuple']['compute_price(bool)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.computePrice(params)))
        resultMappers.push((v) => client.decodeReturnValue('compute_price(bool)uint64', v))
        return this
      },
      /**
       * Add a create_subscription(address,application,application,pay,pay,txn)uint64 method call against the TokenBasedProduct contract
       */
      createSubscription(params: CallParams<TokenBasedProductArgs['obj']['create_subscription(address,application,application,pay,pay,txn)uint64'] | TokenBasedProductArgs['tuple']['create_subscription(address,application,application,pay,pay,txn)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.createSubscription(params)))
        resultMappers.push((v) => client.decodeReturnValue('create_subscription(address,application,application,pay,pay,txn)uint64', v))
        return this
      },
      /**
       * Add a is_subscriber(address)uint64 method call against the TokenBasedProduct contract
       */
      isSubscriber(params: CallParams<TokenBasedProductArgs['obj']['is_subscriber(address)uint64'] | TokenBasedProductArgs['tuple']['is_subscriber(address)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.isSubscriber(params)))
        resultMappers.push((v) => client.decodeReturnValue('is_subscriber(address)uint64', v))
        return this
      },
      /**
       * Add a claim_subscription(asset)void method call against the TokenBasedProduct contract
       */
      claimSubscription(params: CallParams<TokenBasedProductArgs['obj']['claim_subscription(asset)void'] | TokenBasedProductArgs['tuple']['claim_subscription(asset)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.claimSubscription(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a transfer_subscription(address,asset)void method call against the TokenBasedProduct contract
       */
      transferSubscription(params: CallParams<TokenBasedProductArgs['obj']['transfer_subscription(address,asset)void'] | TokenBasedProductArgs['tuple']['transfer_subscription(address,asset)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.transferSubscription(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a delete_subscription(asset)uint64 method call against the TokenBasedProduct contract
       */
      deleteSubscription(params: CallParams<TokenBasedProductArgs['obj']['delete_subscription(asset)uint64'] | TokenBasedProductArgs['tuple']['delete_subscription(asset)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.deleteSubscription(params)))
        resultMappers.push((v) => client.decodeReturnValue('delete_subscription(asset)uint64', v))
        return this
      },
      get update() {
        return {
          bare: (params?: AppClientBareCallParams & AppClientCompilationParams ) => {
            promiseChain = promiseChain.then(async () => composer.addAppUpdate(await client.params.update.bare(params)))
            return this
          },
        }
      },
      get delete() {
        return {
          delete: (params: CallParams<TokenBasedProductArgs['obj']['delete()void'] | TokenBasedProductArgs['tuple']['delete()void']>) => {
            promiseChain = promiseChain.then(async () => composer.addAppDeleteMethodCall(await client.params.delete.delete(params)))
            resultMappers.push(undefined)
            return this
          },
        }
      },
      get optIn() {
        return {
          bare: (params?: AppClientBareCallParams ) => {
            promiseChain = promiseChain.then(() => composer.addAppCall(client.params.optIn.bare(params)))
            return this
          },
        }
      },
      get closeOut() {
        return {
          bare: (params?: AppClientBareCallParams ) => {
            promiseChain = promiseChain.then(() => composer.addAppCall(client.params.closeOut.bare(params)))
            return this
          },
        }
      },
      /**
       * Add a clear state call to the TokenBasedProduct contract
       */
      clearState(params: AppClientBareCallParams) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)))
        return this
      },
      addTransaction(txn: Transaction, signer?: TransactionSigner) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer))
        return this
      },
      async composer() {
        await promiseChain
        return composer
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await (!options ? composer.simulate() : composer.simulate(options))
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      },
      async send(params?: SendParams) {
        await promiseChain
        const result = await composer.send(params)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      }
    } as unknown as TokenBasedProductComposer
  }
}
export type TokenBasedProductComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the get_version()string ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getVersion(params?: CallParams<TokenBasedProductArgs['obj']['get_version()string'] | TokenBasedProductArgs['tuple']['get_version()string']>): TokenBasedProductComposer<[...TReturns, TokenBasedProductReturns['get_version()string'] | undefined]>

  /**
   * Calls the get_discount()(uint64,uint64,uint64,uint64,uint64) ABI method.
   *
   * Returns the discount if exists.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getDiscount(params?: CallParams<TokenBasedProductArgs['obj']['get_discount()(uint64,uint64,uint64,uint64,uint64)'] | TokenBasedProductArgs['tuple']['get_discount()(uint64,uint64,uint64,uint64,uint64)']>): TokenBasedProductComposer<[...TReturns, TokenBasedProductReturns['get_discount()(uint64,uint64,uint64,uint64,uint64)'] | undefined]>

  /**
   * Calls the get_subscription(address)(uint64,uint64,uint64,uint64,uint64) ABI method.
   *
   * Retrieves the subscription details of a given subscriber.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getSubscription(params?: CallParams<TokenBasedProductArgs['obj']['get_subscription(address)(uint64,uint64,uint64,uint64,uint64)'] | TokenBasedProductArgs['tuple']['get_subscription(address)(uint64,uint64,uint64,uint64,uint64)']>): TokenBasedProductComposer<[...TReturns, TokenBasedProductReturns['get_subscription(address)(uint64,uint64,uint64,uint64,uint64)'] | undefined]>

  /**
   * Calls the update_oracle_id(application)void ABI method.
   *
  * Updates the ORACLE (Subtopia Price Oracle) application ID.
  Ars: new_oracle (abi.Application): The new ORACLE application ID.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateOracleId(params?: CallParams<TokenBasedProductArgs['obj']['update_oracle_id(application)void'] | TokenBasedProductArgs['tuple']['update_oracle_id(application)void']>): TokenBasedProductComposer<[...TReturns, TokenBasedProductReturns['update_oracle_id(application)void'] | undefined]>

  /**
   * Calls the update_manager(address)void ABI method.
   *
   * Updates the manager account of the subscription service.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateManager(params?: CallParams<TokenBasedProductArgs['obj']['update_manager(address)void'] | TokenBasedProductArgs['tuple']['update_manager(address)void']>): TokenBasedProductComposer<[...TReturns, TokenBasedProductReturns['update_manager(address)void'] | undefined]>

  /**
   * Calls the update_price(uint64)void ABI method.
   *
   * Updates the price of the subscription service.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updatePrice(params?: CallParams<TokenBasedProductArgs['obj']['update_price(uint64)void'] | TokenBasedProductArgs['tuple']['update_price(uint64)void']>): TokenBasedProductComposer<[...TReturns, TokenBasedProductReturns['update_price(uint64)void'] | undefined]>

  /**
   * Calls the update_lifecycle(uint64)void ABI method.
   *
   * Set product lifecycle state (ENABLED/DISABLED). Only callable by the manager.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateLifecycle(params?: CallParams<TokenBasedProductArgs['obj']['update_lifecycle(uint64)void'] | TokenBasedProductArgs['tuple']['update_lifecycle(uint64)void']>): TokenBasedProductComposer<[...TReturns, TokenBasedProductReturns['update_lifecycle(uint64)void'] | undefined]>

  /**
   * Calls the is_discount_expired()uint64 ABI method.
   *
   * Checks if the discount for the specified duration is expired.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  isDiscountExpired(params?: CallParams<TokenBasedProductArgs['obj']['is_discount_expired()uint64'] | TokenBasedProductArgs['tuple']['is_discount_expired()uint64']>): TokenBasedProductComposer<[...TReturns, TokenBasedProductReturns['is_discount_expired()uint64'] | undefined]>

  /**
   * Calls the create_discount(uint64,uint64,uint64,pay)void ABI method.
   *
   * Creates a new discount for the subscription service.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  createDiscount(params?: CallParams<TokenBasedProductArgs['obj']['create_discount(uint64,uint64,uint64,pay)void'] | TokenBasedProductArgs['tuple']['create_discount(uint64,uint64,uint64,pay)void']>): TokenBasedProductComposer<[...TReturns, TokenBasedProductReturns['create_discount(uint64,uint64,uint64,pay)void'] | undefined]>

  /**
   * Calls the delete_discount()void ABI method.
   *
   * Deletes a discount for the subscription service.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  deleteDiscount(params?: CallParams<TokenBasedProductArgs['obj']['delete_discount()void'] | TokenBasedProductArgs['tuple']['delete_discount()void']>): TokenBasedProductComposer<[...TReturns, TokenBasedProductReturns['delete_discount()void'] | undefined]>

  /**
   * Calls the compute_price(bool)uint64 ABI method.
   *
   * Computes the price of the subscription for the given duration.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  computePrice(params?: CallParams<TokenBasedProductArgs['obj']['compute_price(bool)uint64'] | TokenBasedProductArgs['tuple']['compute_price(bool)uint64']>): TokenBasedProductComposer<[...TReturns, TokenBasedProductReturns['compute_price(bool)uint64'] | undefined]>

  /**
   * Calls the create_subscription(address,application,application,pay,pay,txn)uint64 ABI method.
   *
  * Subscribes a user to the subscription service and creates a new
  subscription.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  createSubscription(params?: CallParams<TokenBasedProductArgs['obj']['create_subscription(address,application,application,pay,pay,txn)uint64'] | TokenBasedProductArgs['tuple']['create_subscription(address,application,application,pay,pay,txn)uint64']>): TokenBasedProductComposer<[...TReturns, TokenBasedProductReturns['create_subscription(address,application,application,pay,pay,txn)uint64'] | undefined]>

  /**
   * Calls the is_subscriber(address)uint64 ABI method.
   *
   * Checks if a given address is a subscriber of the subscription service.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  isSubscriber(params?: CallParams<TokenBasedProductArgs['obj']['is_subscriber(address)uint64'] | TokenBasedProductArgs['tuple']['is_subscriber(address)uint64']>): TokenBasedProductComposer<[...TReturns, TokenBasedProductReturns['is_subscriber(address)uint64'] | undefined]>

  /**
   * Calls the claim_subscription(asset)void ABI method.
   *
   * Allows a subscriber to claim their subscription.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  claimSubscription(params?: CallParams<TokenBasedProductArgs['obj']['claim_subscription(asset)void'] | TokenBasedProductArgs['tuple']['claim_subscription(asset)void']>): TokenBasedProductComposer<[...TReturns, TokenBasedProductReturns['claim_subscription(asset)void'] | undefined]>

  /**
   * Calls the transfer_subscription(address,asset)void ABI method.
   *
   * Transfers a subscription from the sender's address to a new address.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  transferSubscription(params?: CallParams<TokenBasedProductArgs['obj']['transfer_subscription(address,asset)void'] | TokenBasedProductArgs['tuple']['transfer_subscription(address,asset)void']>): TokenBasedProductComposer<[...TReturns, TokenBasedProductReturns['transfer_subscription(address,asset)void'] | undefined]>

  /**
   * Calls the delete_subscription(asset)uint64 ABI method.
   *
  * Unsubscribes a user from the subscription service and deletes the
  subscription.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  deleteSubscription(params?: CallParams<TokenBasedProductArgs['obj']['delete_subscription(asset)uint64'] | TokenBasedProductArgs['tuple']['delete_subscription(asset)uint64']>): TokenBasedProductComposer<[...TReturns, TokenBasedProductReturns['delete_subscription(asset)uint64'] | undefined]>

  /**
   * Gets available delete methods
   */
  readonly delete: {
    /**
     * Deletes an existing instance of the TokenBasedProduct smart contract using the delete()void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    delete(params?: CallParams<TokenBasedProductArgs['obj']['delete()void'] | TokenBasedProductArgs['tuple']['delete()void']>): TokenBasedProductComposer<[...TReturns, TokenBasedProductReturns['delete()void'] | undefined]>
  }

  /**
   * Gets available optIn methods
   */
  readonly optIn: {
    /**
     * Opts the user into an existing instance of the TokenBasedProduct smart contract using a bare call.
     *
     * @param args The arguments for the bare call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    bare(params?: AppClientBareCallParams ): TokenBasedProductComposer<[...TReturns, undefined]>
  }

  /**
   * Gets available closeOut methods
   */
  readonly closeOut: {
    /**
     * Makes a close out call to an existing instance of the TokenBasedProduct smart contract using a bare call.
     *
     * @param args The arguments for the bare call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    bare(params?: AppClientBareCallParams ): TokenBasedProductComposer<[...TReturns, undefined]>
  }

  /**
   * Gets available update methods
   */
  readonly update: {
    /**
     * Updates an existing instance of the TokenBasedProduct smart contract using a bare call.
     *
     * @param args The arguments for the bare call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    bare(params?: AppClientBareCallParams ): TokenBasedProductComposer<[...TReturns, undefined]>
  }

  /**
   * Makes a clear_state call to an existing instance of the TokenBasedProduct smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(params?: AppClientBareCallParams): TokenBasedProductComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn A transaction to add to the transaction group
   * @param signer The optional signer to use when signing this transaction.
   */
  addTransaction(txn: Transaction, signer?: TransactionSigner): TokenBasedProductComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  composer(): Promise<TransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(): Promise<TokenBasedProductComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  simulate(options: SkipSignaturesSimulateOptions): Promise<TokenBasedProductComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  simulate(options: RawSimulateOptions): Promise<TokenBasedProductComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  /**
   * Sends the transaction group to the network and returns the results
   */
  send(params?: SendParams): Promise<TokenBasedProductComposerResults<TReturns>>
}
export type TokenBasedProductComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
  returns: TReturns
}>

